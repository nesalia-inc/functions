---
title: Context
description: Understanding and using context in your APIs
---

# Context

Context is the heart of DeesseJS Functions. It provides data that's available to all your query and mutation handlers, such as database connections, user sessions, logging, and more.

## What is Context?

Context is an object containing values that are:

- **Available to all handlers** - Every query and mutation receives the context
- **Type-safe** - Fully typed with TypeScript
- **Defined once** - Single source of truth for your API
- **Immutable during execution** - Context doesn't change while a request is processed

## Defining Context

Use `defineContext` to create your context:

```ts
import { defineContext } from "@deessejs/functions";

const { t, createAPI } = defineContext<{
  userId: string;
  database: Database;
  logger: Logger;
}>({
  userId: "user-123",
  database: myDatabase,
  logger: myLogger,
});
```

### Context Type

The first type parameter defines the shape of your context:

```ts
defineContext<{
  userId: string;
  database: Database;
  logger: Logger;
}>
```

### Context Values

The argument to `defineContext` provides the actual values:

```ts
defineContext<{ ... }>({
  userId: getCurrentUser().id,
  database: createDatabaseConnection(),
  logger: createLogger(),
});
```

## Using Context in Handlers

Context is always the **first argument** to handlers:

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // ctx BEFORE args âœ…
    console.log("Request from user:", ctx.userId);

    const user = await ctx.database.find(args.id);
    ctx.logger.info("Fetched user", { id: args.id });

    return success(user);
  },
});
```

## Context Composition

You can compose multiple context values:

```ts
// Database module
const createDatabaseContext = () => ({
  database: {
    users: { find: ..., create: ... },
    posts: { find: ..., create: ... },
  },
});

// Auth module
const createAuthContext = () => ({
  userId: getCurrentUser().id,
  userRole: getCurrentUser().role,
});

// Logger module
const createLoggerContext = () => ({
  logger: createLogger(),
});

// Combine all
const { t, createAPI } = defineContext({
  ...createDatabaseContext(),
  ...createAuthContext(),
  ...createLoggerContext(),
});
```

## Async Context Resolution

For complex scenarios, you can provide async context when creating the API (legacy HKT API only):

```ts
// With the legacy HKT-based API
const api = createAPI({
  root: { getUser },
  runtimeContext: async () => {
    const user = await fetchUser();
    return {
      userId: user.id,
      database: await connectDatabase(),
    };
  },
});
```

## Context Inference

TypeScript automatically infers context types:

```ts
const { t, createAPI } = defineContext<{
  userId: string;
  database: Database;
}>({ ... });

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // ctx is fully typed:
    ctx.userId;   // string
    ctx.database; // Database
    ctx.other;    // Type error!
  },
});
```

## Context Patterns

### Dependency Injection

Use context to inject dependencies:

```ts
interface Context {
  db: Database;
  cache: Cache;
  email: EmailService;
  logger: Logger;
}

const { t, createAPI } = defineContext<Context>({
  db: new Database(),
  cache: new Cache(),
  email: new EmailService(),
  logger: new Logger(),
});

const sendEmail = t.mutation({
  args: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  handler: async (ctx, args) => {
    await ctx.email.send({
      to: args.to,
      subject: args.subject,
      body: args.body,
    });

    ctx.logger.info("Email sent", { to: args.to });

    return success({ sent: true });
  },
});
```

### Multi-Tenant Context

Build multi-tenant applications:

```ts
interface TenantContext {
  tenantId: string;
  tenantName: string;
  database: TenantDatabase;
  isTenantAdmin: boolean;
}

const { t, createAPI } = defineContext<TenantContext>({
  tenantId: getTenantId(),
  tenantName: getTenantName(),
  database: getTenantDatabase(),
  isTenantAdmin: checkTenantAdmin(),
});

const getTenantData = t.query({
  args: z.object({}),
  handler: async (ctx) => {
    // Automatically scoped to tenant
    const data = await ctx.database.getTenantData();
    return success({
      tenant: ctx.tenantName,
      isAdmin: ctx.isTenantAdmin,
      data,
    });
  },
});
```

### Request-Scoped Context

Different contexts per request:

```ts
function createAPIForUser(user: User) {
  const { t, createAPI } = defineContext<{
    userId: string;
    userRole: "admin" | "user";
    requestId: string;
  }>({
    userId: user.id,
    userRole: user.role,
    requestId: generateRequestId(),
  });

  return createAPI({
    // ... endpoints
  });
}

// Use with different users
const adminAPI = createAPIForUser(adminUser);
const userAPI = createAPIForUser(normalUser);
```

## Best Practices

### 1. Keep Context Focused

Only include what's needed by your handlers:

```ts
// Good - focused context
defineContext<{
  userId: string;
  database: Database;
}>({ ... });

// Avoid - bloated context
defineContext<{
  userId: string;
  database: Database;
  logger: Logger;
  cache: Cache;
  config: Config;
  metrics: Metrics;
  // ... too many things
}>({ ... });
```

### 2. Use Strong Types

Define interfaces for complex context values:

```ts
interface Database {
  users: UserRepository;
  posts: PostRepository;
}

interface Logger {
  info(message: string, meta?: any): void;
  error(message: string, error?: Error): void;
}

defineContext<{ database: Database; logger: Logger }>({ ... });
```

### 3. Provide Context Once

Define context in a single place:

```ts
// context.ts
export const createAPIContext = () => {
  const { t, createAPI } = defineContext<{
    userId: string;
    database: Database;
  }>({
    userId: getCurrentUserId(),
    database: getDatabase(),
  });

  return { t, createAPI };
};

// Import elsewhere
import { createAPIContext } from "./context";
```

### 4. Make Context Immutable

Don't modify context values during execution:

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Bad - mutating context
    ctx.userId = "different-user";

    // Good - context is read-only
    const currentUserId = ctx.userId;

    return success(user);
  },
});
```

## Next Steps

- [Queries & Mutations](/docs/queries-mutations) - Create operations
- [Router](/docs/router) - Organize your API
- [Lifecycle Hooks](/docs/lifecycle-hooks) - Add middleware
