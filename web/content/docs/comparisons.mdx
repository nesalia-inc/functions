---
title: Comparisons
description: See how DeesseJS Functions compares to other solutions
---

import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";
import { Card, Cards } from "fumadocs-ui/components/card";

# Comparisons

See how DeesseJS Functions compares to other popular solutions.

## vs tRPC

<Tabs items={['tRPC', 'DeesseJS Functions']}>
  <Tab value="tRPC">
    ```typescript
    import { initTRPC } from '@trpc/server';
    import { z } from 'zod';

    const t = initTRPC.context<Context>().create();

    const appRouter = t.router({
      getUser: t.procedure
        .input(z.object({ id: z.number() }))
        .query(({ input, ctx }) => {
          return {
            id: input.id,
            requestedBy: ctx.userId,
          };
        }),
    });

    type AppRouter = typeof appRouter;
    ```
  </Tab>
  <Tab value="DeesseJS Functions">
    ```typescript
    import { defineContext, success } from '@deessejs/functions';
    import { z } from 'zod';

    const { t, createAPI } = defineContext<Context>({
      userId: 'user-123',
      database,
    });

    const getUser = t.query({
      args: z.object({ id: z.number() }),
      handler: async (ctx, args) => {
        return success({
          id: args.id,
          requestedBy: ctx.userId,
        });
      },
    });

    const api = createAPI({ getUser });
    ```
  </Tab>
</Tabs>

### Key Differences

| Feature | tRPC | DeesseJS Functions |
|---------|------|-------------------|
| **Type Transport** | Automatic, complex | Explicit, simple |
| **Context** | Manual context prop | Built-in context system |
| **Error Handling** | TRPCError thrown | Outcome types returned |
| **Client Generation** | Auto-generated | Manual but straightforward |
| **Type Complexity** | High (HKT-like) | Low (standard generics) |
| **Learning Curve** | Steeper | Gentler |

### When to Choose DeesseJS Functions

- ✅ You want simpler types without HKT complexity
- ✅ You prefer explicit error handling over exceptions
- ✅ You're building a backend API (not full-stack)
- ✅ You want built-in context management

### When to Choose tRPC

- ✅ You need automatic end-to-end types (frontend + backend)
- ✅ You're building a full-stack app with React
- ✅ You want auto-generated client
- ✅ You don't mind complex type machinery

---

## vs React Query

<Tabs items={['React Query', 'DeesseJS Functions']}>
  <Tab value="React Query">
    ```typescript
    import { useQuery } from '@tanstack/react-query';

    function UserProfile({ userId }: { userId: number }) {
      const { data, error, isLoading } = useQuery({
        queryKey: ['user', userId],
        queryFn: () => fetchUser(userId),
      });

      if (isLoading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;

      return <div>{data.name}</div>;
    }
    ```
  </Tab>
  <Tab value="DeesseJS Functions">
    ```typescript
    import { api } from './api';

    async function getUserProfile(userId: number) {
      const result = await api.users.get({ id: userId });

      if (!result.ok) {
        throw new Error(result.error.message);
      }

      return result.value;
    }

    // Can be used with React Query, SWR, or plain fetch
    ```
  </Tab>
</Tabs>

### Key Differences

| Feature | React Query | DeesseJS Functions |
|---------|-------------|-------------------|
| **Purpose** | Client-side data fetching | Backend API definition |
| **Type Safety** | Manual | Automatic (with TypeScript) |
| **Caching** | Built-in, advanced | Optional, simple |
| **Scope** | Frontend only | Backend (can use with any client) |
| **Validation** | Manual | Built-in (Zod) |

### Actually, They Work Great Together!

```typescript
// DeesseJS Functions for the backend
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.findById(args.id));
  },
});

// React Query for the frontend
function useUser(userId: number) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => api.users.get({ id: userId }),
  });
}
```

---

## vs Express/REST

<Tabs items={['Express', 'DeesseJS Functions']}>
  <Tab value="Express">
    ```typescript
    import express from 'express';
    import { z } from 'zod';

    const app = express();
    app.use(express.json());

    app.get('/api/users/:id', async (req, res) => {
      try {
        const { id } = z.object({
          id: z.coerce().number()
        }).parse(req.params);

        const user = await database.users.findById(id);

        if (!user) {
          return res.status(404).json({ error: 'Not found' });
        }

        res.json(user);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.post('/api/users', async (req, res) => {
      try {
        const input = userSchema.parse(req.body);
        const user = await database.users.create(input);
        res.status(201).json(user);
      } catch (error) {
        if (error instanceof ZodError) {
          return res.status(400).json({ error: error.errors });
        }
        res.status(500).json({ error: error.message });
      }
    });
    ```
  </Tab>
  <Tab value="DeesseJS Functions">
    ```typescript
    import { defineContext, success, Causes } from '@deessejs/functions';
    import { z } from 'zod';

    const { t, createAPI } = defineContext<{
      database: Database;
    }>({
      database,
    });

    const getUser = t.query({
      args: z.object({ id: z.number() }),
      handler: async (ctx, args) => {
        const user = await ctx.database.users.findById(args.id);

        if (!user) {
          return failure(Causes.notFound(args.id, 'User'));
        }

        return success(user);
      },
    });

    const createUser = t.mutation({
      args: userSchema,
      handler: async (ctx, args) => {
        const user = await ctx.database.users.create(args);
        return success(user);
      },
    });

    const api = createAPI({ getUser, createUser });
    ```
  </Tab>
</Tabs>

### Key Differences

| Feature | Express/REST | DeesseJS Functions |
|---------|--------------|-------------------|
| **Type Safety** | Manual runtime validation | Compile-time + runtime |
| **Error Handling** | Try/catch + status codes | Outcome types |
| **Validation** | Manual Zod/Joi | Built-in Zod |
| **Routes** | URL paths | Nested functions |
| **Context** | Middleware chain | Single context object |
| **Boilerplate** | High (parsers, error handlers) | Low |

### When to Choose DeesseJS Functions

- ✅ You want type safety without boilerplate
- ✅ You prefer functional composition over HTTP routes
- ✅ You're building an internal API
- ✅ You want predictable error handling

### When to Choose Express

- ✅ You need public REST APIs
- ✅ You want HTTP-specific features (rate limiting, CORS)
- ✅ You're following REST conventions
- ✅ You need middleware ecosystem

---

## vs Zod

<Callout type="info" title="They're Complementary!">
DeesseJS Functions <strong>uses</strong> Zod internally. They're not competitors -
DeesseJS Functions provides the API layer, Zod provides the validation layer.
</Callout>

```typescript
import { z } from 'zod';
import { defineContext, success } from '@deessejs/functions';

// Define schemas with Zod
const userSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().min(18).optional(),
});

// Use them in DeesseJS Functions
const createUser = t.mutation({
  args: userSchema, // ✅ Full Zod integration
  handler: async (ctx, args) => {
    // args is fully typed!
    return success(await ctx.database.users.create(args));
  },
});
```

---

## Summary Matrix

| Library | Type Safety | Client | Server | Best For |
|---------|-------------|--------|--------|----------|
| **DeesseJS Functions** | ✅ High | ❌ No | ✅ Yes | Backend APIs |
| **tRPC** | ✅ High | ✅ Yes | ✅ Yes | Full-stack apps |
| **React Query** | ⚠️ Manual | ✅ Yes | ❌ No | Client data fetching |
| **Express** | ⚠️ Manual | ❌ No | ✅ Yes | Public REST APIs |
| **Zod** | ✅ Runtime | ❌ No | ❌ No | Validation layer |

## Which One Should You Choose?

<Cards>
  <Card
    title="Choose DeesseJS Functions if..."
    href="/docs/quick-start"
  >
    - You want a type-safe backend API
    - You prefer simple types over HKTs
    - You want built-in context management
    - You like explicit error handling
  </Card>

  <Card
    title="Choose tRPC if..."
    href="https://trpc.io"
  >
    - You need end-to-end type safety
    - You're building a full-stack app
    - You want auto-generated clients
    - You don't mind complex types
  </Card>

  <Card
    title="Choose Express if..."
    href="https://expressjs.com"
  >
    - You need public REST APIs
    - You want HTTP-specific features
    - You prefer conventional routing
    - You need middleware ecosystem
  </Card>

  <Card
    title="Combine them if..."
    href="/docs/quick-start"
  >
    - Use DeesseJS Functions for backend
    - Use React Query for frontend caching
    - Use Zod for validation
    - Use Express for HTTP layer
  </Card>
</Cards>

<Callout type="tip" title="Not Mutually Exclusive">
These tools aren't mutually exclusive! You can use DeesseJS Functions with React Query,
use it alongside Express, or use it with Zod. Choose the right tool for each job.
</Callout>
