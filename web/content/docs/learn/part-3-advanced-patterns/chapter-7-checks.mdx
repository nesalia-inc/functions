---
title: Chapter 7
description: Master the Check system for authorization
---

# Chapter 7: Check System - Authorization

The Check system provides a powerful, composable way to handle authorization and permissions in your API. In this chapter, you'll learn how to protect your endpoints with type-safe authorization logic.

## What you'll learn in this chapter

- What the Check system is and why it matters
- Creating basic checks
- Composing complex permissions
- Integrating checks with queries and mutations
- Real-world authorization patterns

**Estimated reading time:** 30 minutes

---

## What are Checks?

**Checks** are reusable authorization functions that determine if a request should be allowed. They run **before** your handler, providing early validation.

Think of checks as security guards:

```typescript
const deleteUser = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // âŒ Authorization logic mixed with business logic
    if (ctx.userRole !== 'admin') {
      throw new Error('Unauthorized');
    }

    if (args.id === ctx.userId) {
      throw new Error('Cannot delete yourself');
    }

    return success(await ctx.database.users.delete(args.id));
  },
});
```

With checks, authorization is **separated** from business logic:

```typescript
const canDeleteUser = check({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Pure authorization logic
    if (ctx.userRole !== 'admin') return failure();
    if (args.id === ctx.userId) return failure();
    return success();
  },
});

const deleteUser = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Clean business logic
    return success(await ctx.database.users.delete(args.id));
  },
})
  .withCheck(canDeleteUser); // Apply check
```

---

## Your First Check

### Basic Check Structure

```typescript
import { check, success, failure } from '@deessejs/functions';

const isAdmin = check({
  args: z.object({}), // No args needed
  handler: async (ctx) => {
    if (ctx.userRole === 'admin') {
      return success(); // âœ… Authorized
    }
    return failure(new Error('Not an admin')); // âŒ Unauthorized
  },
});
```

**Breaking it down:**

1. **`check()`** - Creates a check (not a query or mutation)
2. **`args`** - Input validation if needed
3. **`handler`** - Authorization logic
4. **`ctx`** - Your context (user, database, etc.)
5. **`success()`** - Check passed, allow request
6. **`failure()`** - Check failed, reject request

---

## Using Checks

### Apply to Queries and Mutations

```typescript
const onlyAdmin = check({
  args: z.object({}),
  handler: async (ctx) => {
    return ctx.userRole === 'admin' ? success() : failure();
  },
});

const getAdminStats = t.query({
  args: z.object({}),
  handler: async (ctx, args) => {
    return success(await ctx.database.getStats());
  },
})
  .withCheck(onlyAdmin); // âœ… Only admins can access
```

If the check fails, the handler **never runs**:

```typescript
// âŒ Non-admin trying to access
const result = await api.getAdminStats({});

console.log(result.ok); // false
console.log(result.error); // "Not an admin"
```

---

## Advanced Check Patterns

### Pattern 1: Resource-Based Authorization

```typescript
const canEditPost = check({
  args: z.object({ postId: z.number() }),
  handler: async (ctx, args) => {
    const post = await ctx.database.posts.findById(args.postId);

    // Admin can edit any post
    if (ctx.userRole === 'admin') {
      return success();
    }

    // Users can only edit their own posts
    if (post.authorId === ctx.userId) {
      return success();
    }

    return failure(new Error('You can only edit your own posts'));
  },
});

const updatePost = t.mutation({
  args: z.object({
    postId: z.number(),
    title: z.string().min(5).optional(),
    content: z.string().min(10).optional(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.update(args.postId, args));
  },
})
  .withCheck(canEditPost);
```

### Pattern 2: Permission Checks

```typescript
const hasPermission = check({
  args: z.object({
    permission: z.string(),
    resourceId: z.number(),
  }),
  handler: async (ctx, args) => {
    const hasPermission = await ctx.database.permissions.check({
      userId: ctx.userId,
      permission: args.permission,
      resourceId: args.resourceId,
    });

    return hasPermission ? success() : failure(new Error('Permission denied'));
  },
});
```

### Pattern 3: Ownership Verification

```typescript
const isResourceOwner = check({
  args: z.object({
    resourceType: z.enum(['post', 'comment', 'file']),
    resourceId: z.number(),
  }),
  handler: async (ctx, args) => {
    let ownerId: number;

    switch (args.resourceType) {
      case 'post':
        const post = await ctx.database.posts.findById(args.resourceId);
        ownerId = post.authorId;
        break;
      case 'comment':
        const comment = await ctx.database.comments.findById(args.resourceId);
        ownerId = comment.authorId;
        break;
      case 'file':
        const file = await ctx.database.files.findById(args.resourceId);
        ownerId = file.uploaderId;
        break;
    }

    return ownerId === ctx.userId
      ? success()
      : failure(new Error('You do not own this resource'));
  },
});
```

### Pattern 4: Role-Based Access Control

```typescript
const hasRole = check({
  args: z.object({
    roles: z.array(z.enum(['admin', 'moderator', 'user'])),
  }),
  handler: async (ctx, args) => {
    return args.roles.includes(ctx.userRole)
      ? success()
      : failure(new Error(`Must be one of: ${args.roles.join(', ')}`));
  },
});

// Usage
const adminOnly = t.mutation({
  // ...
})
  .withCheck(hasRole({ roles: ['admin'] }));

const adminOrModerator = t.mutation({
  // ...
})
  .withCheck(hasRole({ roles: ['admin', 'moderator'] }));
```

### Pattern 5: Time-Based Access

```typescript
const isBusinessHours = check({
  args: z.object({}),
  handler: async (ctx) => {
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay(); // 0 = Sunday, 6 = Saturday

    // Business hours: Mon-Fri, 9 AM - 5 PM
    const isWeekday = day >= 1 && day <= 5;
    const isHour = hour >= 9 && hour < 17;

    return isWeekday && isHour
      ? success()
      : failure(new Error('Only available during business hours'));
  },
});
```

### Pattern 6: Rate Limiting Checks

```typescript
const checkRateLimit = check({
  args: z.object({
    action: z.string(),
    maxRequests: z.number().default(100),
    windowMs: z.number().default(60000), // 1 minute
  }),
  handler: async (ctx, args) => {
    const key = `ratelimit:${ctx.userId}:${args.action}`;

    const count = await ctx.cache.get(key) || 0;

    if (count >= args.maxRequests) {
      return failure(new Error('Rate limit exceeded'));
    }

    // Increment counter
    await ctx.cache.set(key, count + 1, { ttl: args.windowMs });

    return success();
  },
});
```

---

## Composing Checks

Checks are composable - combine them to create complex authorization logic:

```typescript
// Individual checks
const isAdmin = check({
  args: z.object({}),
  handler: async (ctx) => ctx.userRole === 'admin' ? success() : failure(),
});

const isNotSelf = check({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) =>
    args.userId !== ctx.userId ? success() : failure(new Error('Cannot act on yourself'))
});

const hasVerification = check({
  args: z.object({}),
  handler: async (ctx) => ctx.user.isVerified ? success() : failure(),
});

// Compose them
const canBanUser = allChecks(
  isAdmin,
  isNotSelf,
  hasVerification
);

const banUser = t.mutation({
  args: z.object({
    userId: z.number(),
    reason: z.string(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.ban(args.userId, args.reason));
  },
})
  .withCheck(canBanUser); // All checks must pass
```

### anyChecks - At Least One Must Pass

```typescript
const canEditPost = anyChecks(
  // Admins can edit
  check({
    args: z.object({}),
    handler: async (ctx) => ctx.userRole === 'admin' ? success() : failure(),
  }),

  // Authors can edit their own posts
  check({
    args: z.object({ postId: z.number() }),
    handler: async (ctx, args) => {
      const post = await ctx.database.posts.findById(args.postId);
      return post.authorId === ctx.userId ? success() : failure();
    },
  })
);

const updatePost = t.mutation({
  // ...
})
  .withCheck(canEditPost);
```

---

## Real-World Authorization Example

Here's a complete authorization system for a collaborative blog:

```typescript
// ===========================
// BASIC ROLE CHECKS
// ===========================

const isAuthenticated = check({
  args: z.object({}),
  handler: async (ctx) => ctx.userId ? success() : failure(new Error('Not authenticated')),
});

const isAdmin = check({
  args: z.object({}),
  handler: async (ctx) => ctx.userRole === 'admin' ? success() : failure(new Error('Admin only')),
});

const isModerator = check({
  args: z.object({}),
  handler: async (ctx) =>
    ['admin', 'moderator'].includes(ctx.userRole) ? success() : failure(new Error('Moderator only'))
});

// ===========================
// RESOURCE OWNERSHIP
// ===========================

const isPostAuthor = check({
  args: z.object({ postId: z.number() }),
  handler: async (ctx, args) => {
    const post = await ctx.database.posts.findById(args.postId);
    return post.authorId === ctx.userId ? success() : failure(new Error('Not the post author'));
  },
});

const isCommentAuthor = check({
  args: z.object({ commentId: z.number() }),
  handler: async (ctx, args) => {
    const comment = await ctx.database.comments.findById(args.commentId);
    return comment.authorId === ctx.userId ? success() : failure(new Error('Not the comment author'));
  },
});

// ===========================
// COMPLEX PERMISSIONS
// ===========================

const canEditPost = anyChecks(
  isAdmin, // Admins can edit any post
  isPostAuthor // Authors can edit their own posts
);

const canDeletePost = allChecks(
  isAdmin, // Only admins can delete posts
  isAuthenticated
);

const canModerateComment = anyChecks(
  isAdmin,
  isCommentAuthor,
  isModerator
);

// ===========================
// APPLY TO ENDPOINTS
// ===========================

const updatePost = t.mutation({
  args: z.object({
    postId: z.number(),
    title: z.string().min(5).optional(),
    content: z.string().min(10).optional(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.update(args.postId, args));
  },
})
  .withCheck(canEditPost);

const deletePost = t.mutation({
  args: z.object({
    postId: z.number(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.delete(args.postId));
  },
})
  .withCheck(canDeletePost);

const deleteComment = t.mutation({
  args: z.object({
    commentId: z.number(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.comments.delete(args.commentId));
  },
})
  .withCheck(canModerateComment);
```

---

## Check Best Practices

### âœ… DO: Keep Checks Focused

```typescript
// âœ… Good - Single responsibility
const isAdmin = check({
  args: z.object({}),
  handler: async (ctx) => ctx.userRole === 'admin' ? success() : failure(),
});

// âŒ Bad - Doing too much
const adminCheck = check({
  args: z.object({}),
  handler: async (ctx) => {
    if (ctx.userRole !== 'admin') return failure();

    // âŒ Don't do other work in checks!
    await ctx.database.logAdminAction(ctx.userId);
    await ctx.analytics.track('admin_action', { userId: ctx.userId });

    return success();
  },
});
```

### âœ… DO: Use Descriptive Failure Messages

```typescript
// âœ… Good - Clear error messages
const canEdit = check({
  args: z.object({}),
  handler: async (ctx) => {
    if (ctx.user.banned) {
      return failure(new Error('Your account has been banned'));
    }
    if (!ctx.user.verified) {
      return failure(new Error('Please verify your email first'));
    }
    return success();
  },
});

// âŒ Bad - Generic error
const canEdit = check({
  args: z.object({}),
  handler: async (ctx) => {
    if (!ctx.user.verified || ctx.user.banned) {
      return failure(new Error('Unauthorized')); // Not helpful!
    }
    return success();
  },
});
```

### âœ… DO: Cache Check Results

```typescript
// âœ… Good - Cache expensive checks
const hasPremiumAccess = check({
  args: z.object({}),
  handler: async (ctx) => {
    // Check cache first
    const cacheKey = `premium:${ctx.userId}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached !== undefined) {
      return cached ? success() : failure(new Error('Premium required'));
    }

    // Check database
    const hasPremium = await ctx.database.subscriptions.hasPremium(ctx.userId);

    // Cache result for 5 minutes
    await ctx.cache.set(cacheKey, hasPremium, { ttl: 300000 });

    return hasPremium ? success() : failure(new Error('Premium required'));
  },
});
```

---

## What's Next?

You've mastered the Check system! In **Chapter 8**, you'll learn:
- What are lifecycle hooks
- Using beforeInvoke, onSuccess, onError
- Creating middleware with hooks
- Real-world hook patterns

Ready to hook into the lifecycle? Let's go! ðŸš€

---

## Chapter Recap

You learned:
- âœ… What checks are and why they matter
- âœ… Creating basic authorization checks
- âœ… Advanced patterns: resource-based, role-based, time-based
- âœ… Composing checks with allChecks and anyChecks
- âœ… Real-world authorization example
- âœ… Best practices for focused checks

**Next up:** [Chapter 8: Lifecycle Hooks](/learn/part-3-advanced-patterns/chapter-8-lifecycle-hooks) â†’
