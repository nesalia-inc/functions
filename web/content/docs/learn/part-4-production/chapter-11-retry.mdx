---
title: Chapter 11
description: Build resilience with retry patterns
---

# Chapter 11: Retry & Resilience - Handle Failures

Networks fail. APIs go down. Databases timeout. Building resilient APIs means handling these failures gracefully. In this chapter, you'll master retry patterns that keep your API reliable even when things go wrong.

## What you'll learn in this chapter

- Why retries matter
- Built-in retry utilities
- Exponential backoff
- Retry strategies for different scenarios
- Building resilient APIs

**Estimated reading time:** 25 minutes

---

## Why Retry?

Without retries, transient failures cause permanent errors:

```typescript
// ‚ùå Without retry - transient failure = permanent error
const callAPI = t.query({
  args: z.object({ endpoint: z.string() }),
  handler: async (ctx, args) => {
    // If this fails due to network blip, request fails permanently
    const response = await fetch(args.endpoint);
    return success(await response.json());
  },
});
```

With retries, transient failures are handled automatically:

```typescript
// ‚úÖ With retry - transient failure = automatically retried
import { retry, RetryConfigs } from '@deessejs/functions';

const callAPI = retry(
  async (endpoint: string) => {
    const response = await fetch(endpoint);
    return success(await response.json());
  },
  RetryConfigs.network // Built-in retry config
);
```

---

## Built-in Retry Configurations

DeesseJS Functions provides pre-configured retry strategies:

```typescript
import { retry, RetryConfigs } from '@deessejs/functions';

// Network errors - retry 3 times with exponential backoff
retryConfig = RetryConfigs.network

// Database errors - retry 2 times
retryConfig = RetryConfigs.database

// Conservative - retry once
retryConfig = RetryConfigs.conservative

// Aggressive - retry 5 times
retryConfig = RetryConfigs.aggressive

// Custom retry config
retryConfig = {
  maxRetries: 3,
  initialDelay: 1000,
  maxDelay: 10000,
  backoffMultiplier: 2,
  retryableErrors: ['ECONNREFUSED', 'ETIMEDOUT', 'ECONNRESET'],
}
```

---

## Using Retries

### Basic Retry Usage

```typescript
import { retry, RetryConfigs } from '@deessejs/functions';

const fetchWithRetry = retry(
  async (url: string) => {
    const response = await fetch(url);
    return success(await response.json());
  },
  RetryConfigs.network // Pre-configured for network errors
);

// Use in your query/mutation
const fetchExternalData = t.query({
  args: z.object({ endpoint: z.string() }),
  handler: async (ctx, args) => {
    const result = await fetchWithRetry(args.endpoint);

    if (result.ok) {
      return success(result.value);
    }

    // All retries exhausted
    return failure(result.error);
  },
});
```

### Custom Retry Configuration

```typescript
const customRetry = {
  maxRetries: 3,
  initialDelay: 1000,    // Start with 1 second delay
  maxDelay: 10000,        // Max 10 second delay
  backoffMultiplier: 2,   // Double delay each retry
  jitter: true,           // Add randomness to avoid thundering herd
  retryableErrors: [
    'ECONNREFUSED',
    'ETIMEDOUT',
    'ECONNRESET',
    'ENOTFOUND',
  ],
  onRetry: (attempt, error) => {
    console.log(`Retry attempt ${attempt} after error: ${error.message}`);
  },
};

const operationWithRetry = retry(
  async (data: any) => {
    return success(await riskyOperation(data));
  },
  customRetry
);
```

---

## Retry Patterns

### Pattern 1: Network Resilience

```typescript
const callExternalAPI = t.query({
  args: z.object({
    service: z.enum(['users', 'posts', 'comments']),
  }),
  handler: async (ctx, args) => {
    const callWithRetry = retry(
      async (service) => {
        const url = `https://api.example.com/${service}`;
        const response = await fetch(url, {
          timeout: 10000, // 10 second timeout
        });

        if (!response.ok) {
          throw new Error(`API returned ${response.status}`);
        }

        return success(await response.json());
      },
      {
        maxRetries: 3,
        initialDelay: 1000,
        maxDelay: 5000,
        backoffMultiplier: 2,
        retryableErrors: ['ECONNREFUSED', 'ETIMEDOUT', 'ENOTFOUND'],
      }
    );

    const result = await callWithRetry(args.service);

    if (!result.ok) {
      return failure(result.error);
    }

    return success(result.value);
  },
});
```

### Pattern 2: Database Connection Resilience

```typescript
import { retry } from '@deessejs/functions';

const queryWithRetry = retry(
  async (query: string, params: any[]) => {
    try {
      const result = await database.query(query, params);
      return success(result);
    } catch (error) {
      // Retry on connection errors
      if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
        throw error; // Let retry handle it
      }
      // Don't retry on logic errors
      return failure(error);
    }
  },
  {
    maxRetries: 2,
    initialDelay: 500,
    maxDelay: 2000,
    backoffMultiplier: 2,
    jitter: true,
  }
);

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const result = await queryWithRetry(
      'SELECT * FROM users WHERE id = $1',
      [args.id]
    );

    if (!result.ok) {
      return failure(result.error);
    }

    return success(result.value);
  },
});
```

### Pattern 3: Conditional Retry

```typescript
const smartRetry = retry(
  async (operation: string, data: any) => {
    const result = await externalAPI.call(operation, data);

    if (!result.ok) {
      // Retry on server errors (5xx), not client errors (4xx)
      if (result.statusCode >= 500 && result.statusCode < 600) {
        throw result.error;
      }
      // Don't retry client errors
      return failure(result.error);
    }

    return result;
  },
  {
    maxRetries: 3,
    initialDelay: 2000,
    backoffMultiplier: 2,
    shouldRetry: (error) => {
      return error.statusCode >= 500 && error.statusCode < 600;
    },
  }
);
```

### Pattern 4: Retry with Circuit Breaker

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private threshold = 5;
  private timeout = 60000; // 1 minute

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Check if circuit is open
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();

      // Success - reset failure count
      if (this.state === 'half-open') {
        this.state = 'closed';
        this.failures = 0;
      }

      return result;
    } catch (error) {
      this.failures++;
      this.lastFailureTime = Date.now();

      // Open circuit if threshold reached
      if (this.failures >= this.threshold) {
        this.state = 'open';
      }

      throw error;
    }
  }
}

// Use with retry
const circuitBreaker = new CircuitBreaker();

const resilientQuery = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const result = await retry(
      async () => circuitBreaker.execute(async () => {
        const response = await fetch(`https://api.example.com/data/${args.id}`);
        return success(await response.json());
      }),
      RetryConfigs.network
    );

    return result;
  },
});
```

---

## Exponential Backoff

Exponential backoff increases delay between retries:

```typescript
const customRetryConfig = {
  maxRetries: 4,
  initialDelay: 1000,    // Start with 1 second
  backoffMultiplier: 2,   // Double each time

  // Retry timeline:
  // Attempt 1: 0ms
  // Attempt 2: 1000ms (1 second)
  // Attempt 3: 2000ms (2 seconds)
  // Attempt 4: 4000ms (4 seconds)
  // Attempt 5: 8000ms (8 seconds)
  // Total: ~15 seconds max
};
```

### Adding Jitter

Jitter adds randomness to prevent thundering herd:

```typescript
const retryWithJitter = {
  maxRetries: 3,
  initialDelay: 1000,
  backoffMultiplier: 2,
  jitter: true, // ‚úÖ Add randomness

  // Without jitter:
  // - All clients retry at 1000ms, 2000ms, 4000ms
  // - Server gets hammered at exact intervals

  // With jitter:
  // - Client A: 1000ms, 2345ms, 4123ms
  // - Client B: 1200ms, 2100ms, 3900ms
  // - Spreads out the load
};
```

---

## Real-World Retry Example

Here's a complete retry strategy for a payment system:

```typescript
import { retry, RetryConfigs } from '@deessejs/functions';

// ===========================
// PAYMENT GATEWAY RETRY
// ===========================

const processPayment = retry(
  async (paymentData: {
    amount: number;
    paymentMethodId: string;
    orderId: string;
  }) => {
    try {
      const result = await ctx.paymentGateway.charge({
        amount: paymentData.amount,
        method: paymentData.paymentMethodId,
        orderId: paymentData.orderId,
      });

      return success(result);
    } catch (error) {
      // Don't retry certain errors
      if (error.code === 'INSUFFICIENT_FUNDS') {
        return failure(error); // ‚ùå Don't retry
      }

      if (error.code === 'CARD_DECLINED') {
        return failure(error); // ‚ùå Don't retry
      }

      // Retry on transient errors
      if (error.code === 'TIMEOUT' || error.code === 'NETWORK_ERROR') {
        throw error; // ‚úÖ Retry
      }

      return failure(error);
    }
  },
  {
    maxRetries: 2,
    initialDelay: 2000, // 2 seconds
    maxDelay: 5000,    // 5 seconds
    backoffMultiplier: 1.5,
    jitter: true,
    onRetry: (attempt, error) => {
      ctx.logger.warn('Payment retry', {
        attempt,
        orderId: paymentData.orderId,
        error: error.message,
      });
    },
  }
);

const chargeCard = t.mutation({
  args: z.object({
    amount: z.number().positive(),
    paymentMethodId: z.string(),
    orderId: z.string(),
  }),
  handler: async (ctx, args) => {
    const result = await processPayment(args);

    if (!result.ok) {
      // All retries exhausted
      return failure(result.error);
    }

    return success(result.value);
  },
})
  .onError(async (ctx, args, error) => {
    // Log failed payment attempts
    await ctx.database.paymentAttempts.create({
      orderId: args.orderId,
      amount: args.amount,
      paymentMethodId: args.paymentMethodId,
      error: error.message,
      timestamp: new Date(),
    });
  });

// ===========================
// EMAIL SERVICE RETRY
// ===========================

const sendEmail = retry(
  async (emailData: {
    to: string;
    subject: string;
    template: string;
  }) => {
    const result = await ctx.emailService.send(emailData);

    // Retry on temporary failures
    if (!result.ok && result.temporary) {
      throw result.error;
    }

    return result;
  },
  RetryConfigs.conservative // Email service - conservative retries
);

const sendWelcomeEmail = t.mutation({
  args: z.object({
    userId: z.number(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.userId);

    const result = await sendEmail({
      to: user.email,
      subject: 'Welcome!',
      template: 'welcome',
    });

    if (!result.ok) {
      return failure(new Error('Failed to send welcome email'));
    }

    return success({ emailSent: true });
  },
});

// ===========================
// DATABASE QUERY RETRY
// ===========================

const queryWithRetry = retry(
  async (sql: string, params: any[]) => {
    try {
      const result = await ctx.database.query(sql, params);
      return success(result);
    } catch (error) {
      // Retry on connection errors
      if (
        error.code === 'ECONNRESET' ||
        error.code === 'ECONNREFUSED' ||
        error.code === 'ETIMEDOUT'
      ) {
        throw error;
      }
      // Don't retry on SQL errors
      return failure(error);
    }
  },
  RetryConfigs.database
);

const getReport = t.query({
  args: z.object({
    reportId: z.number(),
  }),
  handler: async (ctx, args) => {
    const result = await queryWithRetry(
      'SELECT * FROM reports WHERE id = $1',
      [args.reportId]
    );

    if (!result.ok) {
      return failure(result.error);
    }

    return success(result.value);
  },
});
```

---

## Retry Best Practices

### ‚úÖ DO: Retry Only Transient Errors

```typescript
// ‚úÖ Good - Retry transient errors
const shouldRetry = (error: Error) => {
  const retryableErrors = [
    'ECONNREFUSED',
    'ETIMEDOUT',
    'ECONNRESET',
    'ESERVICEUNAVAILABLE',
    'EPIPE',
    'ENOTFOUND',
  ];

  return retryableErrors.includes(error.code);
};

const smartRetry = retry(
  async (operation) => {
    return success(await operation());
  },
  {
    maxRetries: 3,
    shouldRetry, // Only retry on these errors
  }
);
```

### ‚úÖ DO: Log Retry Attempts

```typescript
const retryWithLogging = retry(
  async (data: any) => {
    return success(await externalAPI.call(data));
  },
  {
    maxRetries: 3,
    initialDelay: 1000,
    onRetry: (attempt, error) => {
      ctx.logger.warn('Retry attempt', {
        attempt,
        error: error.message,
        willRetryIn: calculateNextDelay(attempt),
      });
    },
  }
);
```

### ‚ùå DON'T: Retry Indefinitely

```typescript
// ‚ùå Bad - No max retries
const infiniteRetry = retry(
  async (operation) => {
    while (true) {
      try {
        return success(await operation());
      } catch {
        // Infinite retry - never fails!
      }
    }
  }
);

// ‚úÖ Good - Limited retries
const limitedRetry = retry(
  async (operation) => {
    return success(await operation());
  },
  {
    maxRetries: 3,
    initialDelay: 1000,
  }
);
```

### ‚ùå DON'T: Retry Without Backoff

```typescript
// ‚ùå Bad - Fixed delay, can overwhelm server
const badRetry = {
  maxRetries: 10,
  initialDelay: 1000,
  // No backoff - all retries at 1 second
};

// ‚úÖ Good - Exponential backoff
const goodRetry = {
  maxRetries: 10,
  initialDelay: 1000,
  backoffMultiplier: 2,
  // Delays: 1s, 2s, 4s, 8s, 16s, ...
};
```

---

## What's Next?

Excellent work! You've mastered resilience patterns. In **Chapter 12**, you'll learn:
- Testing strategies
- Writing unit tests
- Integration testing
- Test utilities and helpers

Ready to ensure your API works correctly? Let's go! üöÄ

---

## Chapter Recap

You learned:
- ‚úÖ Why retries matter for resilience
- Built-in retry configurations
- Exponential backoff with jitter
- Real-world payment system retry example
- Retry best practices

**Next up:** [Chapter 12: Testing](/learn/part-4-production/chapter-12-testing) ‚Üí
