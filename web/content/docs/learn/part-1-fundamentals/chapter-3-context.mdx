---
title: Chapter 3
description: Master context - the heart of DeesseJS Functions
---

# Chapter 3: Understanding Context

Context is the **heart** of DeesseJS Functions. It's what makes the framework powerful - allowing you to share data, services, and configuration across all your API endpoints effortlessly.

In this chapter, you'll master context and learn patterns that will make your APIs cleaner and more maintainable.

## What you'll learn in this chapter

- What context is and why it matters
- How to define and use context
- Advanced context patterns
- Context best practices
- Common context pitfalls

**Estimated reading time:** 20 minutes

---

## What is Context?

**Context** is the shared data that all your API endpoints can access. Think of it as the "environment" in which your queries and mutations run.

### Why Do We Need Context?

Without context, you'd have to pass dependencies to every handler manually:

```typescript
// ‚ùå Without context - repetitive and error-prone
const getUser = (userId: string, db: Database, logger: Logger, id: number) => {
  logger.info('Fetching user', { id });
  return db.users.findById(id);
};

const createUser = (userId: string, db: Database, logger: Logger, data: any) => {
  logger.info('Creating user', { data });
  return db.users.create(data);
};

// You have to pass all dependencies every time!
await getUser(userId, db, logger, 1);
await createUser(userId, db, logger, { name: 'Alice' });
```

With context, dependencies are **automatically available**:

```typescript
// ‚úÖ With context - clean and simple
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // ctx.userId, ctx.database, ctx.logger are all available!
    ctx.logger.info('Fetching user', { id: args.id });
    return success(await ctx.database.users.findById(args.id));
  },
});
```

---

## Defining Context

### Basic Context Definition

```typescript
import { defineContext } from '@deessejs/functions';

// 1. Define the shape of your context
interface Context {
  userId: string;
  database: Database;
  logger: Logger;
}

// 2. Create the context builder
const { t, createAPI } = defineContext<Context>({
  userId: 'user-123',
  database: myDatabase,
  logger: myLogger,
});
```

**What happens here:**

1. **Type Definition** - TypeScript knows what's in context
2. **Context Builder** - `defineContext` creates two tools:
   - `t` - Builds queries and mutations with access to context
   - `createAPI` - Combines endpoints into an API

### Context Values

Context can contain **any serializable data**:

```typescript
interface Context {
  // Simple values
  userId: string;
  environment: 'development' | 'production';

  // Objects
  database: Database;
  logger: Logger;

  // Functions
  sendEmail: (to: string, subject: string) => Promise<void>;

  // Configuration
  config: {
    apiKey: string;
    maxRetries: number;
  };
}
```

> **Good to know:** Context values are created **once** when you call `defineContext`, then shared across all requests in development. In production, you'd typically create a new context per request (for things like user sessions).

---

## Accessing Context in Handlers

Context is always the **first argument** to your handlers:

```typescript
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    //            ^^^^ Context
    //                      ^^^^ Validated args

    // Access context values
    console.log(ctx.userId);      // 'user-123'
    console.log(ctx.database);    // Database object
    console.log(ctx.logger);      // Logger object

    // Use context values
    ctx.logger.info('Fetching user', {
      userId: ctx.userId,
      requestedId: args.id
    });

    return success(await ctx.database.users.findById(args.id));
  },
});
```

**Handler signature is always:**
```typescript
handler: async (ctx: Context, args: ValidatedArgs) => Result
```

---

## Real-World Context Patterns

### Pattern 1: User Session

```typescript
interface Context {
  // User session
  userId: string;
  userRole: 'admin' | 'user' | 'guest';
  permissions: string[];
}

const { t, createAPI } = defineContext<Context>({
  // In a real app, decode JWT or session cookie
  userId: getSessionUserId(request),
  userRole: getSessionUserRole(request),
  permissions: getSessionPermissions(request),
});

// Now all endpoints know who's making the request
const deletePost = t.mutation({
  args: z.object({ postId: z.number() }),
  handler: async (ctx, args) => {
    // Check permissions
    if (!ctx.permissions.includes('delete:post')) {
      throw new Error('Unauthorized');
    }

    // Admin can delete any post
    if (ctx.userRole !== 'admin') {
      const post = await db.posts.findById(args.postId);
      if (post.authorId !== ctx.userId) {
        throw new Error('Can only delete your own posts');
      }
    }

    await db.posts.delete(args.postId);
    return success({ deleted: true });
  },
});
```

### Pattern 2: Database Connection

```typescript
interface Context {
  database: {
    users: UserRepository;
    posts: PostRepository;
    comments: CommentRepository;
  };
}

const { t, createAPI } = defineContext<Context>({
  database: {
    users: new UserRepository(dbConnection),
    posts: new PostRepository(dbConnection),
    comments: new CommentRepository(dbConnection),
  },
});

// Access repositories directly from context
const getUserPosts = t.query({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    const posts = await ctx.database.posts.findByAuthor(args.userId);
    return success(posts);
  },
});
```

### Pattern 3: External Services

```typescript
interface Context {
  services: {
    email: EmailService;
    storage: StorageService;
    analytics: AnalyticsService;
  };
}

const { t, createAPI } = defineContext<Context>({
  services: {
    email: new EmailService(process.env.SENDGRID_API_KEY),
    storage: new StorageService(process.env.AWS_S3_BUCKET),
    analytics: new AnalyticsService(process.env.GA_MEASUREMENT_ID),
  },
});

const sendWelcomeEmail = t.mutation({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.userId);

    await ctx.services.email.send({
      to: user.email,
      template: 'welcome',
    });

    ctx.services.analytics.track('user_welcomed', { userId: user.id });

    return success({ sent: true });
  },
});
```

### Pattern 4: Configuration

```typescript
interface Context {
  config: {
    environment: 'development' | 'staging' | 'production';
    features: {
      enableCache: boolean;
      enableAnalytics: boolean;
      maxFileSize: number;
    };
  };
}

const { t, createAPI } = defineContext<Context>({
  config: {
    environment: process.env.NODE_ENV,
    features: {
      enableCache: process.env.ENABLE_CACHE === 'true',
      enableAnalytics: process.env.ENABLE_ANALYTICS === 'true',
      maxFileSize: parseInt(process.env.MAX_FILE_SIZE || '10485760'),
    },
  },
});

const uploadFile = t.mutation({
  args: z.object({
    name: z.string(),
    size: z.number(),
    data: z.string(),
  }),
  handler: async (ctx, args) => {
    // Access config
    if (args.size > ctx.config.features.maxFileSize) {
      throw new Error('File too large');
    }

    // Conditional features
    if (ctx.config.features.enableCache) {
      // Use cache
    }

    return success({ url: uploadedUrl });
  },
});
```

---

## Context Best Practices

### ‚úÖ DO: Keep Context Focused

```typescript
// ‚úÖ Good - Only what endpoints need
interface Context {
  userId: string;
  database: Database;
}

// ‚ùå Bad - Too much unrelated stuff
interface Context {
  userId: string;
  database: Database;
  appVersion: string;
  buildDate: Date;
  gitCommit: string;
  // ... tons of stuff
}
```

**Rule of thumb:** If an endpoint doesn't use it, it probably doesn't belong in context.

### ‚úÖ DO: Use Type Aliases for Complex Contexts

```typescript
// ‚úÖ Good - Organized with type aliases
type DatabaseContext = {
  users: UserRepository;
  posts: PostRepository;
  comments: CommentRepository;
};

type ServiceContext = {
  email: EmailService;
  storage: StorageService;
};

interface Context {
  userId: string;
  database: DatabaseContext;
  services: ServiceContext;
}
```

### ‚úÖ DO: Make Context Immutable

```typescript
// ‚úÖ Good - Context is read-only
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Treat ctx as read-only
    console.log(ctx.userId);

    // ‚ùå Don't do this:
    // ctx.userId = 'new-user'; // ERROR!

    return success(await ctx.database.users.findById(args.id));
  },
});
```

### ‚ùå DON'T: Put Request-Specific Data in Context

```typescript
// ‚ùå Bad - Request data in context
interface Context {
  userId: string;
  currentRequestId: string; // This changes per request!
  requestBody: any;        // This is what args is for!
}

// ‚úÖ Good - Context is stable, args has request data
interface Context {
  userId: string;
  database: Database;
}
```

---

## Advanced: Dynamic Context

Sometimes you need **per-request context** (like user sessions). Here's how:

```typescript
// Context factory function
function createContextForRequest(request: Request) {
  const token = request.headers.get('authorization')?.replace('Bearer ', '');
  const user = decodeJWT(token);

  return defineContext<Context>({
    userId: user.id,
    userRole: user.role,
    database: myDatabase, // Shared
    logger: myLogger,     // Shared
  });
}

// Use it per request
app.post('/api/*', async (request) => {
  const { t, createAPI } = createContextForRequest(request);

  // Create API with request-specific context
  const api = createAPI({ getUser, createUser });

  // Handle the request
  // ...
});
```

> **Good to know:** In most cases, you'll create context once per application startup. Per-request context is only needed for things like user authentication that change with each request.

---

## Common Context Pitfalls

### ‚ùå Pitfall 1: Circular Dependencies

```typescript
// ‚ùå Bad - Context depends on API, API depends on context
import { api } from './api';

const { t } = defineContext<{
  api: typeof api; // Circular!
}>({});

// ‚úÖ Good - Extract what you actually need
interface Context {
  database: Database;
  logger: Logger;
}
```

### ‚ùå Pitfall 2: God Object

```typescript
// ‚ùå Bad - Everything in context
interface Context {
  user: User;
  database: Database;
  logger: Logger;
  email: EmailService;
  storage: StorageService;
  cache: CacheService;
  queue: QueueService;
  websocket: WebSocketService;
  // ... 20 more things
}

// ‚úÖ Good - Group related items
interface Context {
  user: User;
  infra: Infrastructure;
  services: Services;
}
```

### ‚ùå Pitfall 3: Ignoring TypeScript

```typescript
// ‚ùå Bad - Using `any` loses type safety
const { t } = defineContext<any>({});

// ‚úÖ Good - Proper typing
interface Context {
  userId: string;
  database: Database;
}
const { t } = defineContext<Context>({});
```

---

## Testing with Context

When testing, you can mock context:

```typescript
import { defineContext } from '@deessejs/functions';

// Mock context for testing
const mockContext = defineContext<{
  userId: string;
  database: jest.Mocked<Database>;
}>({
  userId: 'test-user',
  database: {
    users: {
      findById: jest.fn().mockResolvedValue({ id: 1, name: 'Test User' }),
    },
  },
});

const { t } = mockContext;

// Test your query with mocked context
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.findById(args.id));
  },
});

// Test
test('getUser fetches from database', async () => {
  const result = await getUser.handler(mockContext, { id: 1 });

  expect(result.ok).toBe(true);
  expect(result.value).toEqual({ id: 1, name: 'Test User' });
});
```

---

## What's Next?

Congratulations! You now understand context - the foundation of DeesseJS Functions.

In **Part 2: Core Concepts**, you'll dive deeper into:
- **Chapter 4: Queries** - Advanced patterns for reading data
- **Chapter 5: Mutations** - Writing data with confidence
- **Chapter 6: Routers** - Organizing large APIs

Ready to build on your context knowledge? Let's go! üöÄ

---

## Chapter Recap

You learned:
- ‚úÖ What context is and why it's powerful
- ‚úÖ How to define and use context
- ‚úÖ Real-world context patterns (sessions, databases, services)
- ‚úÖ Best practices and common pitfalls
- ‚úÖ How to test with context

**Next up:** [Part 2: Core Concepts](/learn/part-2-core-concepts/chapter-4-queries) ‚Üí
