---
title: Standalone Operations
description: Using queries and mutations outside the API builder
---

import { Callout } from "fumadocs-ui/components/callout";

# Standalone Operations

You can use queries and mutations as standalone operations outside of the API builder for maximum flexibility.

## Standalone Query

Create a query without the API builder:

```ts
import { query, success } from "@deessejs/functions";

const doubleNumber = query({
  args: z.object({ number: z.number() }),
  handler: async (ctx, args) => {
    return success({ result: args.number * 2 });
  },
})
  .beforeInvoke(() => console.log("Starting calculation..."))
  .onSuccess(() => console.log("Calculation complete"));

// Execute with context
const result = await doubleNumber(
  { database: db, logger: log }, // context
  { number: 5 } // args
);

if (result.ok) {
  console.log(result.value); // { result: 10 }
}
```

## Standalone Mutation

Create a mutation without the API builder:

```ts
import { mutation, success } from "@deessejs/functions";

const createUser = mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.create(args);
    return success(user);
  },
})
  .onSuccess(async (ctx, args, user) => {
    await ctx.email.sendWelcome(user.email);
  });

// Execute with context
const result = await createUser(
  { database: db, email: emailService },
  { name: "Alice", email: "alice@example.com" }
);

if (result.ok) {
  console.log("Created:", result.value);
}
```

## Use Cases

### Testing

Test individual operations in isolation:

```ts
import { query, success } from "@deessejs/functions";

const getUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
});

// In tests
describe("getUser", () => {
  it("should return user by ID", async () => {
    const mockDb = {
      users: {
        find: vi.fn().mockResolvedValue({ id: 1, name: "Alice" }),
      },
    };

    const result = await getUser(
      { database: mockDb },
      { id: 1 }
    );

    expect(result.ok).toBe(true);
    expect(result.value).toEqual({ id: 1, name: "Alice" });
  });
});
```

### Composition

Combine multiple operations:

```ts
const fetchUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
});

const fetchUserPosts = query({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.posts.findByUser(args.userId));
  },
});

// Compose operations
async function getUserWithPosts(userId: number) {
  const context = { database: db };

  const userResult = await fetchUser(context, { id: userId });
  if (!userResult.ok) {
    return userResult;
  }

  const postsResult = await fetchUserPosts(context, { userId });
  if (!postsResult.ok) {
    return postsResult;
  }

  return success({
    user: userResult.value,
    posts: postsResult.value,
  });
}
```

### Conditional Execution

Execute operations conditionally:

```ts
const expensiveOperation = query({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.analytics.compute(args.userId));
  },
})
  .beforeInvoke((ctx, args) => {
    if (!ctx.features.expensiveAnalytics) {
      throw new Error("Feature not enabled");
    }
  });

// Conditionally execute
if (features.expensiveAnalytics) {
  const result = await expensiveOperation(
    { database: db, features },
    { userId: 1 }
  );
}
```

### Dynamic Context

Use different contexts for the same operation:

```ts
const getData = query({
  args: z.object({ key: z.string() }),
  handler: async (ctx, args) => {
    return success(await ctx.store.get(args.key));
  },
});

// With different contexts
const fromCache = await getData(
  { store: cacheStore },
  { key: "user:123" }
);

const fromDb = await getData(
  { store: databaseStore },
  { key: "user:123" }
);
```

## Middleware

### Authentication Middleware

```ts
const withAuth = <T extends QueryDefinition | MutationDefinition>(
  operation: T
): T => {
  return operation.beforeInvoke((ctx, args) => {
    if (!ctx.user) {
      throw new Error("Unauthorized");
    }
  }) as T;
};

const authenticatedQuery = withAuth(
  query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  })
);
```

### Logging Middleware

```ts
const withLogging = <T extends QueryDefinition | MutationDefinition>(
  operation: T,
  name: string
): T => {
  return operation
    .beforeInvoke((ctx, args) => {
      console.log(`[START] ${name}`, { args });
    })
    .onSuccess((ctx, args, value) => {
      console.log(`[SUCCESS] ${name}`, { value });
    })
    .onError((ctx, args, error) => {
      console.log(`[ERROR] ${name}`, { error });
    }) as T;
};

const loggedQuery = withLogging(
  query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  }),
  "getUser"
);
```

### Validation Middleware

```ts
const withValidation = <T extends QueryDefinition | MutationDefinition>(
  operation: T,
  schema: z.ZodType<any>
): T => {
  return operation.beforeInvoke((ctx, args) => {
    const result = schema.safeParse(args);
    if (!result.success) {
      throw new Error(`Validation failed: ${result.error.message}`);
    }
  }) as T;
};

const validatedQuery = withValidation(
  query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  }),
  z.object({
    id: z.number().positive(),
  })
);
```

## Advanced Patterns

### Operation Factory

```ts
function createQuery<TContext, TArgs, TOutput>(
  name: string,
  handler: (ctx: TContext, args: TArgs) => Promise<TOutput>
) {
  return query({
    name,
    args: z.any(),
    handler: async (ctx, args) => {
      return success(await handler(ctx, args));
    },
  })
    .beforeInvoke((ctx, args) => {
      console.log(`[${name}] Starting`, { args });
    })
    .onSuccess((ctx, args, value) => {
      console.log(`[${name}] Complete`, { value });
    });
}

const getUser = createQuery(
  "getUser",
  async (ctx: { database: Database }, args: { id: number }) => {
    return await ctx.database.users.find(args.id);
  }
);
```

### Retry Wrapper

```ts
import { retry } from "@deessejs/functions";

const withRetry = <T extends QueryDefinition | MutationDefinition>(
  operation: T,
  maxAttempts = 3
) => {
  const originalHandler = operation.handler;

  return query({
    args: operation.args,
    handler: retry(
      async (ctx, args) => {
        return await originalHandler(ctx, args);
      },
      { maxAttempts }
    ),
  }) as T;
};

const resilientQuery = withRetry(
  query({
    args: z.object({ url: z.string() }),
    handler: async (ctx, args) => {
      const response = await fetch(args.url);
      return success(await response.json());
    },
  }),
  5
);
```

### Cache Wrapper

```ts
const withCache = <T extends QueryDefinition | MutationDefinition>(
  operation: T,
  ttl: number
) => {
  return operation
    .beforeInvoke(async (ctx, args) => {
      const key = JSON.stringify(args);
      const cached = await ctx.cache.get(key);
      if (cached) {
        return success(cached);
      }
    })
    .onSuccess(async (ctx, args, value) => {
      const key = JSON.stringify(args);
      await ctx.cache.set(key, value, { ttl });
    }) as T;
};

const cachedQuery = withCache(
  query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  }),
  60000 // 1 minute
);
```

## Best Practices

<Callout type="tip">
Use standalone operations for testing and composition, but prefer the API builder for production code.
</Callout>

```ts
// Good - standalone for testing
const testQuery = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => success({}),
});

// Good - API builder for production
const { t, createAPI } = defineContext({ /* ... */ });
const api = createAPI({
  getUser: t.query({ /* ... */ }),
});
```

<Callout type="warn">
Be careful with context types in standalone operations - they're not inferred.
</Callout>

```ts
// Good - explicit context type
const operation = query<{ db: Database }, any, User>({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.find(args.id));
  },
});

// Avoid - implicit context type (any)
const operation = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.find(args.id)); // No type safety
  },
});
```

## Related Documentation

- [Queries & Mutations](/docs/queries-mutations) - Creating operations
- [Lifecycle Hooks](/docs/lifecycle-hooks) - Middleware and hooks
- [Testing](/docs/testing) - Testing strategies
