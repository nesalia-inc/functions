---
title: Retry
description: Automatic retry logic with configurable backoff strategies
---

import { Callout } from "fumadocs-ui/components/callout";

# Retry

The retry utility allows you to automatically retry failed operations with configurable backoff strategies.

## Basic Usage

```ts
import { retry } from "@deessejs/functions";

const fetchWithRetry = retry(
  async (url: string) => {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  },
  {
    maxAttempts: 3,
    initialDelay: 1000,
  }
);

const data = await fetchWithRetry("https://api.example.com/data");
```

## Configuration Options

### maxAttempts

Maximum number of retry attempts (including initial attempt):

```ts
const quickRetry = retry(operation, {
  maxAttempts: 3, // Try 3 times total
});
```

### initialDelay

Initial delay between retries in milliseconds:

```ts
const retryWithDelay = retry(operation, {
  initialDelay: 1000, // Wait 1 second before first retry
});
```

### backoffMultiplier

Multiplier for exponential backoff:

```ts
const exponentialRetry = retry(operation, {
  initialDelay: 1000,
  backoffMultiplier: 2, // 1s, 2s, 4s, 8s, ...
});
```

### maxDelay

Maximum delay between retries in milliseconds:

```ts
const cappedRetry = retry(operation, {
  initialDelay: 1000,
  backoffMultiplier: 2,
  maxDelay: 30000, // Cap at 30 seconds
});
```

### jitter

Add randomness to delays to avoid thundering herd:

```ts
const retryWithJitter = retry(operation, {
  initialDelay: 1000,
  jitter: true, // Add random jitter (default: true)
});
```

### isRetryable

Function to determine if an error is retryable:

```ts
const selectiveRetry = retry(operation, {
  isRetryable: (error) => {
    // Only retry network errors
    return error.message.includes("ECONNREFUSED");
  },
});
```

### onRetry

Callback called before each retry attempt:

```ts
const retryWithLogging = retry(operation, {
  onRetry: async (attempt, error, delay) => {
    console.log(`Retry attempt ${attempt} after ${delay}ms delay`);
    console.log(`Error: ${error.message}`);
  },
});
```

## Pre-configured Strategies

### Quick Retry

For transient failures with quick retries:

```ts
import { RetryConfigs } from "@deessejs/functions";

const quickRetry = retry(operation, RetryConfigs.quick);
// maxAttempts: 3, initialDelay: 1000ms
```

### Standard Retry

For most operations:

```ts
const standardRetry = retry(operation, RetryConfigs.standard);
// maxAttempts: 5, initialDelay: 1000ms
```

### Aggressive Retry

For resilient operations:

```ts
const aggressiveRetry = retry(operation, RetryConfigs.aggressive);
// maxAttempts: 10, initialDelay: 1000ms
```

### Network Retry

For network-specific errors:

```ts
const networkRetry = retry(operation, RetryConfigs.network);
// maxAttempts: 5, isRetryable: networkErrors only
```

### Idempotent Retry

For idempotent operations (safe to retry multiple times):

```ts
const idempotentRetry = retry(operation, RetryConfigs.idempotent);
// maxAttempts: 5, shorter delays
```

## Retry Predicates

Built-in predicates for common error types:

```ts
import { RetryPredicates } from "@deessejs/functions";
```

### Network Errors

```ts
const retryNetwork = retry(operation, {
  isRetryable: RetryPredicates.networkErrors,
});
```

Detects:
- Network errors
- Connection errors
- Timeout errors
- DNS errors

### Server Errors

```ts
const retry5xx = retry(operation, {
  isRetryable: RetryPredicates.serverErrors,
});
```

Retries on HTTP 5xx server errors.

### Rate Limit Errors

```ts
const retryRateLimit = retry(operation, {
  isRetryable: RetryPredicates.rateLimitErrors,
});
```

Retries on HTTP 429 rate limit errors.

### Timeout Errors

```ts
const retryTimeout = retry(operation, {
  isRetryable: RetryPredicates.timeoutErrors,
});
```

Retries on timeout errors.

### Custom Predicates

```ts
const customRetry = retry(operation, {
  isRetryable: (error) => {
    // Retry on specific conditions
    return (
      error.message.includes("temporary") ||
      error.code === "ETIMEDOUT" ||
      error.status >= 500
    );
  },
});
```

## Retry with Outcome

For operations that return an `Outcome`:

```ts
import { retryWithOutcome } from "@deessejs/functions";

const fetchWithOutcome = retryWithOutcome(
  async (url: string) => {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return successOutcome(await response.json());
  },
  {
    maxAttempts: 3,
  }
);

const outcome = await fetchWithOutcome("https://api.example.com/data");

if (outcome._tag === "Success") {
  console.log(outcome.value);
}
```

## Examples

### Fetching with Retry

```ts
const fetchAPI = retry(
  async (endpoint: string) => {
    const response = await fetch(`https://api.example.com${endpoint}`);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  },
  {
    maxAttempts: 5,
    initialDelay: 1000,
    backoffMultiplier: 2,
    maxDelay: 10000,
    isRetryable: RetryPredicates.networkErrors,
    onRetry: (attempt, error, delay) => {
      console.log(`Retrying fetch (attempt ${attempt})`);
    },
  }
);

const users = await fetchAPI("/users");
```

### Database Query with Retry

```ts
const queryWithRetry = retry(
  async (sql: string, params: any[]) => {
    try {
      return await db.query(sql, params);
    } catch (error) {
      if (error.code === "CONNECTION_LOST") {
        throw error; // Retry connection errors
      }
      throw error; // Don't retry other errors
    }
  },
  {
    maxAttempts: 3,
    initialDelay: 500,
    isRetryable: (error) => error.code === "CONNECTION_LOST",
  }
);

const result = await queryWithRetry("SELECT * FROM users", []);
```

### API Call with Timeout

```ts
const fetchWithTimeout = retry(
  async (url: string) => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);

    try {
      const response = await fetch(url, {
        signal: controller.signal,
      });
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  },
  {
    maxAttempts: 3,
    initialDelay: 1000,
    isRetryable: RetryPredicates.timeoutErrors,
  }
);
```

### Retry with Circuit Breaker

```ts
let circuitOpen = false;
let resetTimeout: NodeJS.Timeout | null = null;

const fetchWithCircuitBreaker = retry(
  async (url: string) => {
    if (circuitOpen) {
      throw new Error("Circuit breaker is open");
    }

    const response = await fetch(url);
    if (!response.ok) {
      // Open circuit after 5 failures
      if (response.status >= 500) {
        circuitOpen = true;
        resetTimeout = setTimeout(() => {
          circuitOpen = false;
        }, 30000); // Reset after 30 seconds
      }
      throw new Error(`HTTP ${response.status}`);
    }

    return response.json();
  },
  {
    maxAttempts: 3,
    initialDelay: 1000,
  }
);
```

## Retry with Logging

```ts
import { withRetryLogging } from "@deessejs/functions";

const retryWithLogs = withRetryLogging(
  {
    maxAttempts: 3,
    initialDelay: 1000,
  },
  (message) => console.log(`[Retry] ${message}`)
);

const operation = retry(fetchData, retryWithLogs);
```

## Best Practices

<Callout type="tip">
Use shorter delays for idempotent operations and longer delays for operations that might have side effects.
</Callout>

```ts
// Good - quick retry for idempotent operation
const idempotentRetry = retry(readData, {
  maxAttempts: 5,
  initialDelay: 500,
  jitter: true,
});

// Good - careful retry for write operation
const writeRetry = retry(writeData, {
  maxAttempts: 3,
  initialDelay: 2000,
  isRetryable: (error) => error.code === "CONNECTION_ERROR",
});
```

<Callout type="warn">
Always use `isRetryable` to avoid retrying non-retryable errors like validation errors.
</Callout>

```ts
// Good - selective retry
const retry = retry(operation, {
  isRetryable: (error) => {
    return (
      error.name === "NetworkError" ||
      error.name === "TimeoutError"
    );
  },
});

// Bad - retry everything
const retry = retry(operation, {
  isRetryable: () => true,
});
```

## Related Documentation

- [Error Handling](/docs/error-handling) - Working with errors
- [Advanced Features](/docs/advanced) - More advanced patterns
- [AsyncResult](/docs/types/async-result) - Async operations
