---
title: Lifecycle Hooks
description: Add middleware and side effects to your operations
---

# Lifecycle Hooks

Lifecycle hooks allow you to add middleware and side effects to your queries and mutations. They run at different points during execution.

## Available Hooks

- **`beforeInvoke`** - Runs before the handler (good for validation, logging)
- **`afterInvoke`** - Runs after the handler, regardless of success/failure
- **`onSuccess`** - Runs after a successful result
- **`onError`** - Runs after a failed result

## Before Invoke

Run code before your handler executes:

```ts
import { query, success } from "@deessejs/functions";

const getUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Log the request
    ctx.logger.info("Fetching user", { id: args.id });

    // Track metrics
    ctx.metrics.increment("user.fetch");

    // Validate custom rules
    if (args.id < 0) {
      throw new Error("Invalid user ID");
    }
  });
```

## After Invoke

Run code after your handler completes (success or failure):

```ts
const getUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .afterInvoke(async (ctx, args, result) => {
    // Log completion time
    const duration = Date.now() - startTime;
    ctx.logger.info("Request completed", { duration, result: result.ok });
  });
```

## On Success

Run code when the handler succeeds:

```ts
const createUser = mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.create(args));
  },
})
  .onSuccess(async (ctx, args, user) => {
    // Send welcome email
    await ctx.email.send({
      to: user.email,
      subject: "Welcome!",
      template: "welcome",
    });

    // Audit log
    await ctx.audit.log({
      action: "user.created",
      userId: user.id,
      actor: ctx.userId,
    });

    // Invalidate cache
    await ctx.cache.invalidate("users:list");
  });
```

## On Error

Run code when the handler fails:

```ts
const getUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .onError(async (ctx, args, error) => {
    // Log the error
    ctx.logger.error("Failed to fetch user", {
      id: args.id,
      error: error.message,
    });

    // Track error metrics
    ctx.metrics.increment("user.fetch.error");

    // Send alert for critical errors
    if (error.name === "DatabaseError") {
      await ctx.alerts.send({
        severity: "high",
        message: "Database error fetching user",
        details: error,
      });
    }
  });
```

## Chaining Hooks

You can chain multiple hooks:

```ts
const createUser = mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.create(args));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Validate email is unique
    const exists = await ctx.db.users.findByEmail(args.email);
    if (exists) {
      return failure(
        exception({ name: "Conflict", message: "Email already exists" })
      );
    }
  })
  .beforeInvoke(async (ctx, args) => {
    // Log attempt
    ctx.logger.info("Attempting to create user", { email: args.email });
  })
  .onSuccess(async (ctx, args, user) => {
    // Send welcome email
    await ctx.email.sendWelcome(user.email);
  })
  .onSuccess(async (ctx, args, user) => {
    // Invalidate cache
    await ctx.cache.invalidate("users:list");
  })
  .onError(async (ctx, args, error) => {
    // Log error
    ctx.logger.error("Failed to create user", { error });
  });
```

## Common Patterns

### Authentication

```ts
const protectedQuery = (query: QueryDefinition) =>
  query.beforeInvoke(async (ctx, args) => {
    if (!ctx.userId) {
      throw new Error("Unauthorized");
    }
  });

const getUser = protectedQuery(
  t.query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  })
);
```

### Authorization

```ts
const requireRole = (role: string) => (query: QueryDefinition) =>
  query.beforeInvoke(async (ctx, args) => {
    if (ctx.userRole !== role) {
      throw new Error(`Forbidden: ${role} role required`);
    }
  });

const adminOnlyQuery = requireRole("admin");

const deleteUser = adminOnlyQuery(
  t.mutation({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.delete(args.id));
    },
  })
);
```

### Rate Limiting

```ts
const rateLimit = (key: string, limit: number, window: number) =>
  (query: QueryDefinition) =>
    query.beforeInvoke(async (ctx, args) => {
      const identifier = ctx.userId || ctx.ip;
      const count = await ctx.rateLimit.check(key, identifier, window);

      if (count >= limit) {
        throw new Error("Rate limit exceeded");
      }
    });

const rateLimitedQuery = rateLimit("api", 100, 60000);

const getUsers = rateLimitedQuery(
  t.query({
    args: z.object({}),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.findAll());
    },
  })
);
```

### Logging

```ts
const withLogging = (operation: string) => (query: QueryDefinition) =>
  query
    .beforeInvoke(async (ctx, args) => {
      ctx.logger.info(`${operation} started`, { args });
    })
    .afterInvoke(async (ctx, args, result) => {
      ctx.logger.info(`${operation} completed`, {
        success: result.ok,
        value: result.ok ? result.value : undefined,
      });
    });

const loggedQuery = withLogging("getUser");

const getUser = loggedQuery(
  t.query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  })
);
```

### Caching

```ts
const withCache = (ttl: number) => (query: QueryDefinition) =>
  query
    .beforeInvoke(async (ctx, args) => {
      const cached = await ctx.cache.get(args);
      if (cached) {
        return success(cached);
      }
    })
    .onSuccess(async (ctx, args, value) => {
      await ctx.cache.set(args, value, { ttl });
    });

const cachedQuery = withCache(60000); // 1 minute

const getUser = cachedQuery(
  t.query({
    args: z.object({ id: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.find(args.id));
    },
  })
);
```

### Validation

```ts
const validateSchema = <T>(schema: z.ZodType<T>) =>
  (query: QueryDefinition) =>
    query.beforeInvoke(async (ctx, args) => {
      const result = schema.safeParse(args);
      if (!result.success) {
        return failure(
          exception({
            name: "ValidationError",
            message: result.error.message,
          })
        );
      }
    });

const validatedMutation = validateSchema(
  z.object({
    email: z.string().email(),
    age: z.number().min(18).max(120),
  })
);

const createUser = validatedMutation(
  t.mutation({
    args: z.object({ email: z.string(), age: z.number() }),
    handler: async (ctx, args) => {
      return success(await ctx.db.users.create(args));
    },
  })
);
```

### Transaction Management

```ts
const withTransaction = (query: QueryDefinition) =>
  query
    .beforeInvoke(async (ctx, args) => {
      await ctx.db.beginTransaction();
    })
    .onSuccess(async (ctx, args, value) => {
      await ctx.db.commitTransaction();
    })
    .onError(async (ctx, args, error) => {
      await ctx.db.rollbackTransaction();
    });

const transactionalMutation = withTransaction(
  t.mutation({
    args: z.object({
      amount: z.number(),
      fromUserId: z.number(),
      toUserId: z.number(),
    }),
    handler: async (ctx, args) => {
      await ctx.db.accounts.debit(args.fromUserId, args.amount);
      await ctx.db.accounts.credit(args.toUserId, args.amount);
      return success({ transferred: args.amount });
    },
  })
);
```

## Execution Order

Hooks execute in this order:

1. `beforeInvoke` hooks (in order added)
2. Handler executes
3. `afterInvoke` hooks (in order added)
4. If success: `onSuccess` hooks (in order added)
5. If failure: `onError` hooks (in order added)

## Hook Error Handling

If a hook throws an error:

- **`beforeInvoke`**: Handler doesn't run, `onError` is called
- **`afterInvoke`**: Error is logged, doesn't affect result
- **`onSuccess`**: Error is logged, result is still success
- **`onError`**: Error is logged, original error is preserved

```ts
const getUser = query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .beforeInvoke(async (ctx, args) => {
    throw new Error("Before invoke error");
    // Handler won't run, onError will be called
  })
  .onSuccess(async (ctx, args, value) => {
    throw new Error("Success error");
    // Error is logged, result is still success
  })
  .onError(async (ctx, args, error) => {
    // This will be called with "Before invoke error"
    ctx.logger.error("Error occurred", { error });
  });
```

## Next Steps

- [Error Handling](/docs/error-handling) - Handle errors gracefully
- [Advanced Features](/docs/advanced) - Discover advanced patterns
- [Type System](/docs/types/result) - Learn about Result types
