---
title: Migration Guide
description: Migrate from older versions of DeesseJS Functions
---

# Migration Guide

This guide helps you migrate from older versions of DeesseJS Functions to the latest version.

## Overview

The latest version (v0.1.0+) introduces a **native API** that removes the complexity of Higher Kinded Types (HKT) while maintaining full type safety.

### Key Changes

| Old (v0.0.x HKT-based) | New (v0.1.0 Native) |
|------------------------|---------------------|
| `defineContext().withExtensions([rpc])` | `defineContext(context)` |
| `t.query()` from rpc extension | `t.query()` is native |
| `handler: async (ctx, args)` | `handler: async (ctx, args)` ✅ (unchanged!) |
| `createAPI({ root, runtimeContext })` | `defineContext(context); createAPI(root)` |
| HKT-based types | Standard TypeScript generics |
| Complex type errors | Simple, clear types |
| Slow compilation | Fast compilation |

## Migration Steps

### Step 1: Update Imports

No changes needed! The main exports remain the same:

```ts
// Old (still works)
import { defineContext, rpc } from "@deessejs/functions";

// New (recommended)
import { defineContext, success, failure, exception } from "@deessejs/functions";
```

### Step 2: Simplify Context Definition

**Old (HKT-based):**

```ts
const { t, createAPI } = defineContext<{ userId: string }>()
  .withExtensions([rpc]);
```

**New (Native):**

```ts
const { t, createAPI } = defineContext<{ userId: string }>({
  userId: "user-123" // Provide default value
});
```

**Key Differences:**
- Context is now defined **inline** with values
- No need for `.withExtensions([rpc])`
- `query` and `mutation` are built-in

### Step 3: Remove Extension Imports

**Old:**

```ts
import { defineContext, rpc } from "@deessejs/functions";

const { t, createAPI } = defineContext()
  .withExtensions([rpc]);
```

**New:**

```ts
import { defineContext } from "@deessejs/functions";

const { t, createAPI } = defineContext({
  userId: "user-123"
});
```

### Step 4: Update API Creation

**Old:**

```ts
const api = createAPI({
  root: {
    getUser,
    createUser,
  },
  runtimeContext: {
    userId: "user-123"
  },
});
```

**New:**

```ts
// Context already defined in defineContext
const api = createAPI({
  getUser,
  createUser,
});
```

### Step 5: Update Handler Calls

**Good news:** Handler signatures are unchanged!

```ts
// Old ✅ (still works)
handler: async (ctx, args) => {
  return success({ id: args.id, requestedBy: ctx.userId });
}

// New ✅ (same!)
handler: async (ctx, args) => {
  return success({ id: args.id, requestedBy: ctx.userId });
}
```

## Complete Migration Example

### Before (HKT-based)

```ts
import { defineContext, rpc, success } from "@deessejs/functions";
import { z } from "zod";

const { t, createAPI } = defineContext<{
  userId: string;
  database: Database;
}>()
  .withExtensions([rpc]);

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.find(args.id);
    return success(user);
  },
});

const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.create(args);
    return success(user);
  },
});

const api = createAPI({
  root: {
    getUser,
    createUser,
  },
  runtimeContext: {
    userId: "user-123",
    database: myDatabase,
  },
});

// Usage
const result = await api.getUser({ id: 1 });
```

### After (Native)

```ts
import { defineContext, success } from "@deessejs/functions";
import { z } from "zod";

const { t, createAPI } = defineContext<{
  userId: string;
  database: Database;
}>({
  userId: "user-123",
  database: myDatabase,
});

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.find(args.id);
    return success(user);
  },
});

const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.create(args);
    return success(user);
  },
});

const api = createAPI({
  getUser,
  createUser,
});

// Usage (same!)
const result = await api.getUser({ id: 1 });
```

## Specific Migration Scenarios

### Async Context

**Old:**

```ts
const api = createAPI({
  root: { getUser },
  runtimeContext: async () => {
    const user = await fetchUser();
    return { userId: user.id };
  },
});
```

**New:**

For async context, you have two options:

1. **Resolve async before defineContext** (recommended):
```ts
const user = await fetchUser();

const { t, createAPI } = defineContext({
  userId: user.id,
});

const api = createAPI({ getUser });
```

2. **Use a factory function**:
```ts
async function createAPIForRequest() {
  const user = await fetchUser();

  const { t, createAPI } = defineContext({
    userId: user.id,
  });

  return createAPI({ getUser });
}

const api = await createAPIForRequest();
```

### Multiple Extensions

**Old:**

```ts
import { defineContext, rpc, logging, cache } from "@deessejs/functions";

const { t, createAPI } = defineContext()
  .withExtensions([rpc, logging, cache]);
```

**New:**

Extensions are now optional. If you need them, you can still use the HKT-based API:

```ts
import { defineContext } from "@deessejs/functions";
import { rpcExtension, loggingExtension } from "./extensions";

const { t, createAPI } = defineContext(context, [
  rpcExtension,
  loggingExtension,
]);
```

However, for most use cases, you don't need extensions anymore. Use lifecycle hooks instead:

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .beforeInvoke((ctx, args) => {
    ctx.logger.info("Fetching user", { id: args.id });
  })
  .onSuccess((ctx, args, user) => {
    ctx.cache.set(`user:${args.id}`, user);
  });
```

### Router Organization

**Old:**

```ts
const api = createAPI({
  root: t.router({
    users: t.router({
      get: getUser,
      create: createUser,
    }),
  }),
  runtimeContext: { userId: "123" },
});
```

**New:**

```ts
const api = createAPI({
  users: t.router({
    get: getUser,
    create: createUser,
  }),
});
```

## Breaking Changes

### 1. Context Must Be Provided

The context must now be provided when calling `defineContext()`:

```ts
// Old
const { t, createAPI } = defineContext<{ userId: string }>();

// New
const { t, createAPI } = defineContext<{ userId: string }>({
  userId: "user-123"
});
```

### 2. No Runtime Context Override

You can no longer override context at runtime:

```ts
// Old
const api = createAPI({
  root: { getUser },
  runtimeContext: { userId: "456" }, // Override
});

// New - Create a new context instead
const { t, createAPI } = defineContext({
  userId: "456",
});
const api = createAPI({ getUser });
```

### 3. Extension System Changes

The extension system has been simplified. If you were using custom extensions, you may need to update them:

```ts
// Old extension interface
interface Extension<Ctx> {
  name: string;
  functions?: () => Record<string, any>;
  request?: (state: any, ctx: Ctx) => Promise<Partial<Ctx>>;
  init?: () => any;
}

// New extension interface (simpler)
interface NativeExtension<C> {
  name: string;
  context?: (ctx: C) => Partial<C> | Promise<Partial<C>>;
  methods?: Record<string, (...args: any[]) => any>;
}
```

## Rollback Strategy

If you need to rollback to the old API, you can still use it:

```ts
import { defineContext as defineContextHKT } from "@deessejs/functions/hkt";
import { rpc } from "@deessejs/functions/extensions/rpc";

const { t, createAPI } = defineContextHKT()
  .withExtensions([rpc]);

// Rest of your code remains the same
```

## Benefits of Migrating

After migrating, you'll get:

- ✅ **Faster compilation** - No more HKT type complexity
- ✅ **Better error messages** - Clear, actionable TypeScript errors
- ✅ **Simpler API** - Less boilerplate, more clarity
- ✅ **Same type safety** - Full end-to-end type safety maintained
- ✅ **Better IDE support** - Faster autocomplete and type hints

## Getting Help

If you encounter issues during migration:

1. Check the [examples](https://github.com/your-org/deessejs-functions/tree/main/examples)
2. Review the [API reference](/docs/api)
3. Open an [issue on GitHub](https://github.com/your-org/deessejs-functions/issues)

## Next Steps

- [Getting Started](/docs/getting-started) - Start with the new API
- [Context](/docs/context) - Learn about context in the new API
- [Advanced Features](/docs/retry) - Explore advanced patterns
