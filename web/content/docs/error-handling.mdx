---
title: Error Handling
description: Handle errors gracefully with the Result type and exceptions
---

# Error Handling

DeesseJS Functions provides a robust error handling system based on the `Result` type and `Exception` objects.

## Result Type

All queries and mutations return a `Result<T, E>`:

```ts
type Result<T, E> =
  | { ok: true; value: T }
  | { ok: false; error: E };
```

## Basic Error Handling

### Checking Results

```ts
const result = await api.getUser({ id: 1 });

if (result.ok) {
  // Success
  console.log(result.value);
} else {
  // Error
  console.error(result.error);
}
```

### Returning Success

```ts
import { success } from "@deessejs/functions";

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);
    return success(user);
  },
});
```

### Returning Failure

```ts
import { failure, exception } from "@deessejs/functions";

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);

    if (!user) {
      return failure(
        exception({
          name: "NotFound",
          message: `User ${args.id} not found`,
        })
      );
    }

    return success(user);
  },
});
```

## Exception Type

Exceptions provide structured error information:

```ts
interface Exception {
  name: string;
  message: string;
  namespace?: string;
  cause?: Exception;
  stack?: Exception[];
  notes?: string[];
}
```

### Creating Exceptions

```ts
import { exception } from "@deessejs/functions";

// Simple exception
const error = exception({
  name: "NotFound",
  message: "User not found",
});

// With namespace
const error = exception({
  name: "UserNotFound",
  message: "User not found",
  namespace: "users",
});

// With cause
const error = exception({
  name: "DatabaseError",
  message: "Failed to connect to database",
  cause: exception({
    name: "ConnectionError",
    message: "Connection timeout",
  }),
});

// With notes
const error = exception({
  name: "ValidationError",
  message: "Invalid input",
  notes: [
    "Email is required",
    "Password must be at least 8 characters",
  ],
});
```

### Exception Methods

```ts
const error = exception({
  name: "NotFound",
  message: "User not found",
});

// Add a cause
const withCause = error.from(
  exception({ name: "DatabaseError", message: "Query failed" })
);

// Add a note
const withNote = error.addNote("Suggested action: Check user ID");

// Check if same type
const isSame = error.is(
  exception({ name: "NotFound", message: "Other" })
); // true
```

## Exception Spaces

Group related exceptions:

```ts
import { exceptionSpace } from "@deessejs/functions";

const users = exceptionSpace({
  name: "users",
  severity: "error",
});

// Create namespaced exceptions
const notFound = users.define({
  name: "NotFound",
  message: "User not found",
});

const alreadyExists = users.define({
  name: "AlreadyExists",
  message: "User already exists",
});

const invalidEmail = users.define({
  name: "InvalidEmail",
  message: "Invalid email address",
});
```

## Error Patterns

### Validation Errors

```ts
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    // Check if email already exists
    const existing = await ctx.db.users.findByEmail(args.email);
    if (existing) {
      return failure(
        exception({
          name: "EmailAlreadyExists",
          message: "A user with this email already exists",
          notes: [`Email: ${args.email}`],
        })
      );
    }

    const user = await ctx.db.users.create(args);
    return success(user);
  },
});
```

### Not Found Errors

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);

    if (!user) {
      return failure(
        exception({
          name: "NotFound",
          message: `User with ID ${args.id} not found`,
          namespace: "users",
        })
      );
    }

    return success(user);
  },
});
```

### Authorization Errors

```ts
const deleteUser = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Check if user can delete
    if (ctx.userId !== args.id && ctx.userRole !== "admin") {
      return failure(
        exception({
          name: "Forbidden",
          message: "You don't have permission to delete this user",
        })
      );
    }

    await ctx.db.users.delete(args.id);
    return success({ deleted: true });
  },
});
```

### Database Errors

```ts
const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    try {
      const user = await ctx.db.users.create(args);
      return success(user);
    } catch (error) {
      return failure(
        exception({
          name: "DatabaseError",
          message: "Failed to create user",
          cause: exception({
            name: error.name,
            message: error.message,
          }),
        })
      );
    }
  },
});
```

## Using Error Hooks

Handle errors with lifecycle hooks:

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
})
  .onError(async (ctx, args, error) => {
    // Log all errors
    ctx.logger.error("Failed to get user", {
      id: args.id,
      error: error.message,
    });

    // Track metrics
    ctx.metrics.increment("users.get.error");

    // Send alerts for critical errors
    if (error.name === "DatabaseError") {
      await ctx.alerts.send({
        severity: "high",
        message: "Database error",
        details: error,
      });
    }
  });
```

## Outcome Type

For more advanced error handling, use the `Outcome` type:

```ts
import { successOutcome, failureOutcome, Causes, exceptionOutcome } from "@deessejs/functions";

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);

    if (!user) {
      return failureOutcome(
        Causes.notFound(args.id, "User")
      );
    }

    return successOutcome(user);
  },
});
```

### Outcome Variants

```ts
// Success outcome
return successOutcome({ id: 1, name: "Alice" });

// Failure outcome with causes
return failureOutcome([
  cause({ name: "InvalidName", message: "Name is too short" }),
  cause({ name: "InvalidEmail", message: "Email is invalid" }),
]);

// Exception outcome
return exceptionOutcome(
  exception({
    name: "DatabaseError",
    message: "Connection failed",
  })
);
```

## Error Handling Utilities

### Retry with Error Handling

```ts
import { retry, RetryPredicates } from "@deessejs/functions";

const fetchWithRetry = retry(
  async (url: string) => {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  },
  {
    maxAttempts: 3,
    initialDelay: 1000,
    isRetryable: RetryPredicates.networkErrors,
  }
);
```

### Try/Catch

```ts
import { tryCatch, Try } from "@deessejs/functions";

const result: Try<User> = tryCatch(() => {
  return JSON.parse(userJson);
});

if (result.ok) {
  console.log(result.value);
} else {
  console.error("Failed to parse JSON", result.error);
}
```

## Best Practices

### 1. Use Descriptive Error Names

```ts
// Good - descriptive
return failure(
  exception({
    name: "UserNotFound",
    message: "User not found",
  })
);

// Avoid - generic
return failure(
  exception({
    name: "Error",
    message: "Something went wrong",
  })
);
```

### 2. Include Context in Messages

```ts
// Good - includes context
return failure(
  exception({
    name: "NotFound",
    message: `User ${args.id} not found`,
  })
);

// Avoid - no context
return failure(
  exception({
    name: "NotFound",
    message: "Not found",
  })
);
```

### 3. Use Error Causes

```ts
// Good - includes cause
return failure(
  exception({
    name: "UserCreationFailed",
    message: "Failed to create user",
    cause: exception({
      name: "DatabaseError",
      message: dbError.message,
    }),
  })
);

// Avoid - loses information
return failure(
  exception({
    name: "UserCreationFailed",
    message: "Failed to create user",
  })
);
```

### 4. Add Notes for Guidance

```ts
// Good - includes notes
return failure(
  exception({
    name: "ValidationError",
    message: "Validation failed",
    notes: [
      "Email must be unique",
      "Password must be at least 8 characters",
    ],
  })
);
```

## Next Steps

- [Lifecycle Hooks](/docs/lifecycle-hooks) - Handle errors with hooks
- [Type System](/docs/types/result) - Learn about Result types
- [Advanced Features](/docs/retry) - Discover advanced patterns
