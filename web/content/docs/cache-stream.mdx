---
title: Cache Invalidation Stream
description: Real-time cache coordination and invalidation
---

import { Callout } from "fumadocs-ui/components/callout";

# Cache Invalidation Stream

The cache invalidation stream provides real-time cache coordination between different parts of your application.

## Basic Usage

```ts
import { createCacheStream } from "@deessejs/functions";

const stream = createCacheStream();

// Subscribe to cache changes
const unsubscribe = stream.subscribe("users:123", (event) => {
  if (event.type === "invalidation") {
    console.log("Cache invalidated for", event.key);
    // Refetch data
    refetchUser(123);
  }
});

// Invalidate cache
stream.invalidate("users:123", {
  tags: ["users"],
  data: { reason: "User updated" },
});

// Later: unsubscribe();
```

## Creating a Stream

```ts
import { createCacheStream } from "@deessejs/functions";

// Create with custom history size
const stream = createCacheStream({
  maxHistorySize: 500,
});
```

## Invalidation Methods

### invalidate

Invalidate a single cache key:

```ts
const event = stream.invalidate("users:123", {
  tags: ["users", "user"],
  data: { userId: 123, reason: "Update" },
});

// Returns the invalidation event
console.log(event.key); // "users:123"
console.log(event.timestamp); // Date
```

### invalidateMany

Invalidate multiple cache keys at once:

```ts
const events = stream.invalidateMany(
  ["users:1", "users:2", "users:3"],
  {
    tags: ["users"],
    data: { reason: "Batch update" },
  }
);

// Returns array of invalidation events
console.log(events.length); // 3
```

### invalidateByTag

Invalidate all cache entries matching a tag:

```ts
const events = stream.invalidateByTag("users", {
  reason: "Bulk update",
});

// Invalidates all keys subscribed with "users" tag
```

## Mutation Notifications

### notifyMutation

Notify subscribers of a mutation event:

```ts
import { successOutcome } from "@deessejs/functions";

const mutationEvent = stream.notifyMutation(
  "createUser",
  successOutcome({ id: 1, name: "Alice" })
);

// Returns the mutation event
console.log(mutationEvent.operation); // "createUser"
console.log(mutationEvent.result); // { id: 1, name: "Alice" }
```

## Subscription Methods

### subscribe

Subscribe to cache invalidation events for a key:

```ts
const unsubscribe = stream.subscribe(
  "users:123",
  (event) => {
    if (event.type === "invalidation") {
      console.log("Invalidated:", event.key);
      console.log("Tags:", event.tags);
      console.log("Data:", event.data);
    }
  }
);

// Unsubscribe later
unsubscribe();
```

### subscribeByTags

Subscribe to all events matching specific tags:

```ts
const unsubscribe = stream.subscribeByTags(
  ["users", "posts"],
  (event) => {
    console.log("Event:", event);
    // Receives events with "users" or "posts" tags
  }
);
```

### subscribeToMutations

Subscribe to mutation events for specific operations:

```ts
const unsubscribe = stream.subscribeToMutations(
  ["createUser", "updateUser", "deleteUser"],
  (event) => {
    if (event.type === "mutation") {
      console.log("Operation:", event.operation);
      console.log("Result:", event.result);
      console.log("Error:", event.error);
    }
  }
);
```

### Subscription Options

Add filters to subscriptions:

```ts
const unsubscribe = stream.subscribe(
  "users:123",
  (event) => {
    console.log("Event:", event);
  },
  {
    filters: {
      tags: ["users", "profile"],
      operations: ["createUser", "updateUser"],
    },
  }
);
```

## Stream Utilities

```ts
import { StreamUtils } from "@deessejs/functions";
```

### Creating Keys

```ts
const key = StreamUtils.key("users", 123); // "users:123"
const complexKey = StreamUtils.key("api", "v1", "users", 123);
// "api:v1:users:123"
```

### Parsing Keys

```ts
const parts = StreamUtils.parseKey("users:123"); // ["users", "123"]
const complexParts = StreamUtils.parseKey("api:v1:users:123");
// ["api", "v1", "users", "123"]
```

### Pattern Matching

```ts
const pattern = StreamUtils.pattern("users:*");
// Regex: /^users:.*$/

const matches = StreamUtils.matchesPattern("users:123", "users:*");
// true

const matches2 = StreamUtils.matchesPattern("posts:123", "users:*");
// false
```

### Extracting Tags

```ts
const taggedKey = StreamUtils.withTags("users:123", ["user", "profile"]);
// "users:123:#user:#profile"

const tags = StreamUtils.extractTags("users:123:#user:#profile");
// ["user", "profile"]
```

## Stream Statistics

### Get Subscriptions

```ts
const subscriptions = stream.getSubscriptions();
console.log(`Active subscriptions: ${subscriptions.length}`);

subscriptions.forEach(sub => {
  console.log(`- ${sub.key} (${sub.id})`);
});
```

### Get Subscription Count

```ts
const count = stream.getSubscriptionCount("users:123");
console.log(`Subscriptions for users:123: ${count}`);
```

### Get Event History

```ts
// Get all history
const allEvents = stream.getHistory();

// Get last 10 events
const recentEvents = stream.getHistory(10);

events.forEach(event => {
  console.log(`${event.type}: ${event.key || event.operation}`);
});
```

### Get Statistics

```ts
const stats = stream.getStats();
console.log(`Total subscriptions: ${stats.totalSubscriptions}`);
console.log(`Active subscriptions: ${stats.activeSubscriptions}`);
console.log(`Event history size: ${stats.eventHistorySize}`);
console.log(`Max history size: ${stats.maxHistorySize}`);
```

### Clear History

```ts
stream.clearHistory();
```

### Clear Subscriptions

```ts
stream.clearSubscriptions();
```

### Set Max History Size

```ts
stream.setMaxHistorySize(500);
```

## Examples

### Cache Invalidation with Queries

```ts
const updateUser = t.mutation({
  args: z.object({
    id: z.number(),
    name: z.string(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.update(args.id, {
      name: args.name,
    });

    // Invalidate cache
    ctx.cacheStream.invalidate(`users:${args.id}`, {
      tags: ["users"],
      data: { user },
    });

    // Also invalidate list
    ctx.cacheStream.invalidateByTag("users");

    return success(user);
  },
});
```

### Real-time Updates

```ts
// Subscribe to user changes
const unsubscribe = stream.subscribe("users:123", (event) => {
  if (event.type === "invalidation") {
    // Refetch and update UI
    fetchUser(123).then(user => {
      updateUserUI(user);
    });
  }
});

// Update user
await api.updateUser({ id: 123, name: "Alice" });
// Cache is automatically invalidated, UI updates
```

### Multi-Region Cache Sync

```ts
// Region 1
const stream1 = createCacheStream();
stream1.subscribeByTags(["users"], (event) => {
  // Forward to region 2
  forwardToRegion2(event);
});

// Region 2
const stream2 = createCacheStream();
stream2.subscribeByTags(["users"], (event) => {
  // Forward to region 1
  forwardToRegion1(event);
});
```

### Distributed Cache

```ts
// Subscribe to cache events
stream.subscribeByTags(["users", "posts"], async (event) => {
  // Broadcast to Redis
  await redis.publish("cache:invalidation", JSON.stringify(event));
});

// Listen for Redis messages
redis.subscribe("cache:invalidation", (message) => {
  const event = JSON.parse(message);

  if (event.type === "invalidation") {
    // Invalidate local cache
    stream.invalidate(event.key, event);
  }
});
```

### Cache Warming

```ts
// Pre-warm cache on startup
async function warmCache() {
  const users = await db.users.findAll();

  for (const user of users) {
    const key = `users:${user.id}`;
    await cache.set(key, user);

    // Subscribe to changes
    stream.subscribe(key, (event) => {
      if (event.type === "invalidation") {
        // Refetch from database
        db.users.find(user.id).then(fresh => {
          cache.set(key, fresh);
        });
      }
    });
  }
}
```

## Best Practices

<Callout type="tip">
Use tags to group related cache entries for bulk invalidation.
</Callout>

```ts
// Good - use tags
stream.invalidate("users:123", { tags: ["users", "user"] });
stream.invalidateByTag("users"); // Invalidates all users

// Bad - manual tracking
stream.invalidate("users:123");
stream.invalidate("users:456");
stream.invalidate("users:789");
```

<Callout type="warn">
Always unsubscribe when you're done to prevent memory leaks.
</Callout>

```ts
// Good - unsubscribe
const unsubscribe = stream.subscribe("key", callback);
// Later
unsubscribe();

// Bad - never unsubscribe
stream.subscribe("key", callback); // Leaks memory
```

<Callout type="tip">
Use history for debugging and monitoring.
</Callout>

```ts
// Monitor cache invalidation rate
setInterval(() => {
  const stats = stream.getStats();
  const history = stream.getHistory(100);

  const invalidations = history.filter(e => e.type === "invalidation");
  console.log(`Invalidation rate: ${invalidations.length}/100`);
}, 60000);
```

## Related Documentation

- [Advanced Features](/docs/advanced) - More advanced patterns
- [Lifecycle Hooks](/docs/lifecycle-hooks) - Cache with hooks
- [Mutation](/docs/queries-mutations) - Mutation operations
