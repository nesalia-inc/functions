---
title: Command Aliases
description: Provide multiple names for the same operation
---

import { Callout } from "fumadocs-ui/components/callout";

# Command Aliases

Command aliases allow you to provide multiple names for the same operation, useful for backward compatibility and API evolution.

## Basic Usage

```ts
import { aliases } from "@deessejs/functions";

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
});

// Add aliases
aliases(getUser, ["fetchUser", "retrieveUser", "getUserById"]);

// All work the same
await api.getUser({ id: 1 });
await api.fetchUser({ id: 1 });
await api.retrieveUser({ id: 1 });
await api.getUserById({ id: 1 });
```

## Use Cases

### Backward Compatibility

Maintain old endpoint names while introducing new ones:

```ts
const v1_getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
});

// v1 endpoint
aliases(v1_getUser, ["getUser_v1", "fetchUser_v1"]);

// v2 endpoint with improved logic
const v2_getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.db.users.find(args.id);
    return success(user);
  },
});

// Primary name + aliases
aliases(v2_getUser, ["getUser", "fetchUser"]);
```

### API Evolution

Gradually rename operations without breaking existing code:

```ts
// Old name: createUserAccount
// New name: createUser (simpler)
const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.create(args));
  },
});

// Keep old name for compatibility
aliases(createUser, ["createUserAccount", "registerUser", "signupUser"]);
```

### Semantic Variations

Provide semantically similar names for better API ergonomics:

```ts
const deleteUser = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    await ctx.db.users.delete(args.id);
    return success({ deleted: true });
  },
});

// All mean the same thing
aliases(deleteUser, [
  "removeUser",
  "destroyUser",
  "eliminateUser",
]);
```

### Domain-Specific Names

Different teams can use different names for the same operation:

```ts
const createOrder = t.mutation({
  args: z.object({
    userId: z.number(),
    items: z.array(z.object({
      productId: z.number(),
      quantity: z.number(),
    })),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.orders.create(args));
  },
});

// Sales team uses "placeOrder"
// Inventory team uses "createOrder"
// Finance team uses "processOrder"
aliases(createOrder, [
  "placeOrder",
  "processOrder",
  "submitOrder",
]);
```

## Version Compatibility

### Multiple API Versions

```ts
// v1 API
const apiV1 = createAPI({
  users: t.router({
    getUser: t.query({
      args: z.object({ userId: z.number() }),
      handler: async (ctx, args) => {
        return success(await ctx.db.users.find(args.userId));
      },
    }),
  }),
});

// v2 API with renamed parameter
const apiV2 = createAPI({
  users: t.router({
    getUser: t.query({
      args: z.object({ id: z.number() }),
      handler: async (ctx, args) => {
        return success(await ctx.db.users.find(args.id));
      },
    }),
    // Add v1 alias for compatibility
    getUserByUserId: t.query({
      args: z.object({ userId: z.number() }),
      handler: async (ctx, args) => {
        return success(await ctx.db.users.find(args.userId));
      },
    }),
  }),
});

// Alias v2 to v1 name
aliases(apiV2.users.getUser, ["getUserByUserId"]);
```

### Gradual Migration

```ts
// Step 1: Add new endpoint
const newUserEndpoint = t.query({
  args: z.object({ userId: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.userId));
  },
});

// Step 2: Alias to old name
aliases(newUserEndpoint, ["oldUserEndpoint"]);

// Step 3: Gradually migrate clients
// Clients can use either name during transition

// Step 4: Remove old alias (after migration period)
```

## Organization

### Grouping Aliases

```ts
// User operations
const getUser = t.query({ /* ... */ });
const createUser = t.mutation({ /* ... */ });
const updateUser = t.mutation({ /* ... */ });
const deleteUser = t.mutation({ /* ... */ });

aliases(getUser, ["fetchUser", "retrieveUser"]);
aliases(createUser, ["registerUser", "signupUser"]);
aliases(updateUser, ["modifyUser", "editUser"]);
aliases(deleteUser, ["removeUser", "destroyUser"]);
```

### Documentation

```ts
/**
 * Get a user by ID
 *
 * @aliases fetchUser, retrieveUser, getUserById
 *
 * @example
 * // All of these work:
 * await api.getUser({ id: 1 });
 * await api.fetchUser({ id: 1 });
 * await api.retrieveUser({ id: 1 });
 * await api.getUserById({ id: 1 });
 */
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.db.users.find(args.id));
  },
});

aliases(getUser, ["fetchUser", "retrieveUser", "getUserById"]);
```

## Best Practices

<Callout type="tip">
Use aliases sparingly. Too many aliases can make your API confusing.
</Callout>

```ts
// Good - focused aliases for compatibility
aliases(getUser, ["fetchUser"]);
aliases(deleteUser, ["removeUser"]);

// Avoid - too many aliases
aliases(getUser, [
  "fetchUser",
  "retrieveUser",
  "getUserById",
  "findUser",
  "queryUser",
  "loadUser",
  "getUserData",
  "fetchUserData",
  // ... too many!
]);
```

<Callout type="warn">
Document your aliases clearly so users know which names are available.
</Callout>

```ts
// Good - documented in code
/**
 * Primary endpoint: getUser
 * Aliases: fetchUser (legacy), retrieveUser (internal use)
 */
const getUser = t.query({ /* ... */ });
aliases(getUser, ["fetchUser", "retrieveUser"]);

// Avoid - undocumented
const getUser = t.query({ /* ... */ });
aliases(getUser, ["fetchUser", "retrieveUser"]);
// Users don't know about aliases!
```

<Callout type="tip">
Use a naming convention to distinguish primary names from aliases.
</Callout>

```ts
// Good - clear naming
const getUser = t.query({ /* ... */ }); // Primary name
aliases(getUser, ["getUser_v1", "getUser_legacy"]); // Aliases are clear

// Avoid - unclear naming
const getUser_v1 = t.query({ /* ... */ }); // Which is primary?
aliases(getUser_v1, ["getUser", "fetchUser"]);
```

## Deprecation

### Deprecating Aliases

```ts
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // Log deprecation warning
    if (args._deprecated) {
      ctx.logger.warn(
        `"${args._deprecated}" is deprecated. Use "getUser" instead.`
      );
    }

    return success(await ctx.db.users.find(args.id));
  },
})
  .beforeInvoke((ctx, args) => {
    // Detect which alias was used
    const caller = new Error().stack?.split("\n")[2];
    if (caller?.includes("fetchUser")) {
      console.warn("fetchUser is deprecated, use getUser instead");
    }
  });

// Keep deprecated alias
aliases(getUser, ["fetchUser"]);
```

### Sunset Timeline

```ts
// Phase 1: Introduce new name
const newUserEndpoint = t.query({ /* ... */ });
// Old name still primary
const oldUserEndpoint = t.query({ /* ... */ });

// Phase 2: Add alias (1 month)
aliases(newUserEndpoint, ["oldUserEndpoint"]);
// Document deprecation

// Phase 3: Warn about deprecation (3 months)
// Log warnings when old name is used

// Phase 4: Remove alias (6 months)
// Remove the alias, keep only new name
```

## Related Documentation

- [Router](/docs/router) - Organizing endpoints
- [Queries & Mutations](/docs/queries-mutations) - Creating operations
- [Migration](/docs/migration) - API migration strategies
