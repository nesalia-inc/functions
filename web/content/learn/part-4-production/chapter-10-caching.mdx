---
title: Chapter 10
description: Master caching strategies for performance
---

# Chapter 10: Caching - Performance at Scale

Caching is one of the most effective ways to improve API performance. In this chapter, you'll learn how to implement intelligent caching strategies that keep your API fast while maintaining data consistency.

## What you'll learn in this chapter

- Why caching matters
- DeesseJS Functions caching architecture
- Cache invalidation strategies
- Best practices for cache keys
- Real-world caching patterns

**Estimated reading time:** 25 minutes

---

## Why Cache?

Without caching, every request hits your database:

```typescript
// ‚ùå Without caching - 1000 requests = 1000 database queries
const getPopularPosts = t.query({
  args: z.object({ limit: z.number().default(10) }),
  handler: async (ctx, args) => {
    // Runs EVERY time
    return success(await ctx.database.posts.getPopular(args.limit));
  },
});
```

With caching, popular data is served from memory:

```typescript
// ‚úÖ With caching - 1000 requests = 1 database query + 999 cache hits
const getPopularPosts = t.query({
  args: z.object({ limit: z.number().default(10) }),
  handler: async (ctx, args) => {
    const cacheKey = `popular:${args.limit}`;

    // Check cache first
    const cached = await ctx.cache.get(cacheKey);
    if (cached) {
      return success(cached); // ‚úÖ Cache hit!
    }

    // Cache miss - fetch from database
    const posts = await ctx.database.posts.getPopular(args.limit);

    // Store in cache for 5 minutes
    await ctx.cache.set(cacheKey, posts, { ttl: 300 });

    return success(posts);
  },
});
```

**Performance impact:**
- Cache hit: ~1ms (from memory)
- Cache miss: ~50ms (from database)
- **50x faster** with cache!

---

## DeesseJS Functions Caching Architecture

DeesseJS Functions provides a built-in caching system:

```typescript
import { createCacheStream } from '@deessejs/functions';

const cache = createCacheStream();

// Subscribe to invalidation events
cache.subscribe('posts:*', (event) => {
  if (event.type === 'invalidation') {
    // Clear matching cache entries
    await ctx.cache.deleteByTag('posts');
  }
});

// Invalidate when data changes
await cache.invalidate('posts:123', {
  tags: ['posts'],
  data: { reason: 'Post updated' }
});
```

---

## Basic Caching Patterns

### Pattern 1: Simple Time-Based Cache

```typescript
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const cacheKey = `user:${args.id}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      return success(cached);
    }

    const user = await ctx.database.users.findById(args.id);

    // Cache for 5 minutes
    await ctx.cache.set(cacheKey, user, { ttl: 300 });

    return success(user);
  },
})
  .onSuccess(async (ctx, args, data) => {
    // Warm the cache after successful fetch
    await ctx.cache.set(`user:${args.id}`, data, { ttl: 300 });
  });
```

### Pattern 2: Tag-Based Cache

```typescript
const getPosts = t.query({
  args: z.object({
    limit: z.number().default(20),
  }),
  handler: async (ctx, args) => {
    const cacheKey = `posts:limit:${args.limit}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      return success(cached);
    }

    const posts = await ctx.database.posts.findAll({
      limit: args.limit,
    });

    // Store with tags for easy invalidation
    await ctx.cache.set(cacheKey, posts, {
      ttl: 300,
      tags: ['posts', 'posts:list'],
    });

    return success(posts);
  },
});
```

### Pattern 3: User-Specific Cache

```typescript
const getUserFeed = t.query({
  args: z.object({
    limit: z.number().default(20),
  }),
  handler: async (ctx, args) => {
    const cacheKey = `feed:${ctx.userId}:${args.limit}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      return success(cached);
    }

    const feed = await ctx.database.posts.getFeed(ctx.userId, {
      limit: args.limit,
    });

    // Cache for 1 minute (feed changes frequently)
    await ctx.cache.set(cacheKey, feed, {
      ttl: 60,
      tags: [`feed:${ctx.userId}`],
    });

    return success(feed);
  },
});
```

---

## Cache Invalidation Strategies

### Strategy 1: Time-Based Invalidation

```typescript
const getStats = t.query({
  args: z.object({}),
  handler: async (ctx, args) => {
    const cached = await ctx.cache.get('stats');
    if (cached) return success(cached);

    const stats = await ctx.database.getStats();

    // Stats update every 5 minutes, so cache for 4 minutes
    await ctx.cache.set('stats', stats, { ttl: 240 });

    return success(stats);
  },
});
```

### Strategy 2: Write-Through Cache

```typescript
const updatePost = t.mutation({
  args: z.object({
    id: z.number(),
    title: z.string().optional(),
    content: z.string().optional(),
  }),
  handler: async (ctx, args) => {
    const updated = await ctx.database.posts.update(args.id, args);

    // Update cache immediately
    await ctx.cache.set(`post:${updated.id}`, updated, {
      ttl: 300,
      tags: ['posts', `post:${updated.id}`],
    });

    return success(updated);
  },
})
  .onSuccess(async (ctx, args, data) => {
    // Invalidate list caches
    await ctx.cache.deleteByTag('posts:list');
    await ctx.cache.delete(`posts:author:${data.authorId}`);
  });
```

### Strategy 3: Event-Based Invalidation

```typescript
import { createCacheStream } from '@deessejs/functions';

const cacheStream = createCacheStream();

// Listen for post updates
cacheStream.subscribe('posts:*', async (event) => {
  if (event.type === 'invalidation') {
    await ctx.cache.deleteByTag('posts');
  }
});

const deletePost = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    await ctx.database.posts.delete(args.id);

    // Emit invalidation event
    cacheStream.invalidate(`posts:${args.id}`, {
      tags: ['posts', `posts:author:${ctx.userId}`],
      data: { reason: 'Post deleted' }
    });

    return success({ deleted: true });
  },
});
```

---

## Advanced Caching Patterns

### Pattern 1: Stale-While-Revalidate

```typescript
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const cacheKey = `user:${args.id}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      // Return stale data immediately
      const promise = (async () => {
        // Revalidate in background
        const fresh = await ctx.database.users.findById(args.id);
        await ctx.cache.set(cacheKey, fresh, { ttl: 300 });
      })();

      return success({ data: cached, revalidating: promise });
    }

    const user = await ctx.database.users.findById(args.id);
    await ctx.cache.set(cacheKey, user, { ttl: 300 });

    return success({ data: user });
  },
});
```

### Pattern 2: Hierarchical Cache

```typescript
const getUserWithPosts = t.query({
  args: z.object({
    userId: z.number(),
    postsLimit: z.number().default(5),
  }),
  handler: async (ctx, args) => {
    // Try to get complete data from cache
    const fullCacheKey = `user:${args.userId}:posts:${args.postsLimit}`;
    const cached = await ctx.cache.get(fullCacheKey);

    if (cached) {
      return success(cached);
    }

    // Check partial caches
    const userCacheKey = `user:${args.userId}`;
    const postsCacheKey = `user:posts:${args.userId}:${args.postsLimit}`;

    let user = await ctx.cache.get(userCacheKey);
    let posts = await ctx.cache.get(postsCacheKey);

    // Fetch missing data
    if (!user) {
      user = await ctx.database.users.findById(args.userId);
      await ctx.cache.set(userCacheKey, user, { ttl: 300 });
    }

    if (!posts) {
      posts = await ctx.database.posts.findByUser(args.userId, {
        limit: args.postsLimit,
      });
      await ctx.cache.set(postsCacheKey, posts, { ttl: 60 });
    }

    const result = { user, posts };

    // Cache combined result
    await ctx.cache.set(fullCacheKey, result, { ttl: 60 });

    return success(result);
  },
});
```

### Pattern 3: Conditional Caching

```typescript
const getConfig = t.query({
  args: z.object({ key: z.string() }),
  handler: async (ctx, args) => {
    const cacheKey = `config:${args.key}`;

    // Don't cache sensitive config
    if (args.key.startsWith('secret_')) {
      return success(await ctx.database.config.get(args.key));
    }

    // Cache non-sensitive config
    const cached = await ctx.cache.get(cacheKey);
    if (cached) return success(cached);

    const config = await ctx.database.config.get(args.key);
    await ctx.cache.set(cacheKey, config, { ttl: 600 }); // 10 minutes

    return success(config);
  },
});
```

---

## Cache Key Best Practices

### ‚úÖ DO: Use Hierarchical Keys

```typescript
// ‚úÖ Good - Clear hierarchy
'user:123'
'user:123:posts'
'user:123:posts:5'
'posts:list'
'posts:popular'

// ‚ùå Bad - Flat structure
'user_123_posts'
'user123_posts_5'
'posts_list_popular_limit_20'
```

### ‚úÖ DO: Include Context in Keys

```typescript
// ‚úÖ Good - Context-specific
`feed:${ctx.userId}`
`feed:${ctx.userId}:page:${page}`
`settings:${ctx.userId}:theme`

// ‚ùå Bad - Shared cache, wrong data leak
`feed:page:1` // ‚ùå Shared across all users!
`settings:theme` // ‚ùå One user's theme affects everyone
```

### ‚úÖ DO: Use Consistent Naming

```typescript
// ‚úÖ Good - Consistent patterns
'<resource>:<id>'          // Single resource
'<resource>:<id>:<sub>'  // Nested resource
'<resource>:list'       // Collection
'<resource>:<action>'    // Action-based

// Examples
'post:123'
'post:123:comments'
'posts:list'
'posts:popular'
```

---

## Real-World Caching Example

Here's a complete caching strategy for a blog API:

```typescript
import { createCacheStream } from '@deessejs/functions';

const cacheStream = createCacheStream();

// ===========================
// QUERIES WITH CACHING
// ===========================

const getPost = t.query({
  args: z.object({
    id: z.number(),
    includeComments: z.boolean().default(false),
  }),
  handler: async (ctx, args) => {
    const cacheKey = `post:${args.id}:comments:${args.includeComments}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      // Add X-Cache header for debugging
      return success({ ...cached, _cache: 'HIT' });
    }

    const post = await ctx.database.posts.findById(args.id);

    if (args.includeComments) {
      post.comments = await ctx.database.comments.findByPost(post.id);
    }

    // Cache for 5 minutes
    await ctx.cache.set(cacheKey, post, {
      ttl: 300,
      tags: ['posts', `post:${post.id}`, `posts:author:${post.authorId}`],
    });

    return success({ ...post, _cache: 'MISS' });
  },
});

const getPopularPosts = t.query({
  args: z.object({
    limit: z.number().default(10),
    timeframe: z.enum(['day', 'week', 'month']).default('week'),
  }),
  handler: async (ctx, args) => {
    const cacheKey = `posts:popular:${args.timeframe}:${args.limit}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      return success(cached);
    }

    const posts = await ctx.database.posts.getPopular({
      limit: args.limit,
      timeframe: args.timeframe,
    });

    // Cache for different durations based on timeframe
    const ttl = {
      day: 60,     // 1 minute
      week: 300,   // 5 minutes
      month: 3600, // 1 hour
    }[args.timeframe];

    await ctx.cache.set(cacheKey, posts, {
      ttl,
      tags: ['posts', 'posts:popular'],
    });

    return success(posts);
  },
});

// ===========================
// MUTATIONS WITH INVALIDATION
// ===========================

const updatePost = t.mutation({
  args: z.object({
    id: z.number(),
    title: z.string().min(5).optional(),
    content: z.string().min(10).optional(),
  }),
  handler: async (ctx, args) => {
    const updated = await ctx.database.posts.update(args.id, args);

    // Update cache
    await ctx.cache.set(`post:${updated.id}`, updated, {
      ttl: 300,
      tags: ['posts', `post:${updated.id}`],
    });

    // Emit invalidation event
    cacheStream.invalidate(`posts:${updated.id}`, {
      tags: ['posts', `post:${updated.id}`, `posts:author:${ctx.userId}`],
      data: { reason: 'Post updated', postId: updated.id },
    });

    return success(updated);
  },
});

const deletePost = t.mutation({
  args: z.object({
    id: z.number(),
  }),
  handler: async (ctx, args) => {
    await ctx.database.posts.delete(args.id);

    // Delete from cache
    await ctx.cache.delete(`post:${args.id}`);

    // Emit invalidation
    cacheStream.invalidate(`posts:${args.id}`, {
      tags: ['posts', `posts:author:${ctx.userId}`],
      data: { reason: 'Post deleted', postId: args.id },
    });

    return success({ deleted: true });
  },
});

// ===========================
// CACHE WARMING
// ===========================

const warmCache = async () => {
  // Warm popular posts cache on startup
  const popular = await database.posts.getPopular(20);

  await cache.set('posts:popular:week:20', popular, {
    ttl: 300,
    tags: ['posts', 'posts:popular'],
  });

  console.log('‚úÖ Cache warmed: popular posts');
};
```

---

## Cache Best Practices

### ‚úÖ DO: Cache Expensive Operations

```typescript
// ‚úÖ Good - Cache expensive queries
const getAnalytics = t.query({
  args: z.object({
    userId: z.number(),
    dateRange: z.object({
      start: z.date(),
      end: z.date(),
    }),
  }),
  handler: async (ctx, args) => {
    const cacheKey = `analytics:${ctx.userId}:${args.dateRange.start}:${args.dateRange.end}`;
    const cached = await ctx.cache.get(cacheKey);

    if (cached) {
      return success(cached);
    }

    // Expensive computation
    const analytics = await ctx.database.analytics.compute(args);

    // Cache for longer since analytics doesn't change often
    await ctx.cache.set(cacheKey, analytics, { ttl: 3600 });

    return success(analytics);
  },
});
```

### ‚úÖ DO: Use Appropriate TTLs

```typescript
// ‚úÖ Good - TTL based on data change frequency
const cacheConfig = {
  // Fast-changing: short TTL
  userFeed: 60,          // 1 minute
  notifications: 30,     // 30 seconds

  // Medium-changing: medium TTL
  posts: 300,            // 5 minutes
  comments: 180,         // 3 minutes
  userProfile: 600,     // 10 minutes

  // Slow-changing: long TTL
  config: 3600,          // 1 hour
  settings: 7200,        // 2 hours
  permissions: 86400,    // 24 hours
};
```

### ‚ùå DON'T: Cache Sensitive Data

```typescript
// ‚ùå Bad - Caching sensitive user data
const getCreditCard = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const card = await ctx.database.payments.getCreditCard(args.id);

    // ‚ùå Don't cache credit card numbers!
    await ctx.cache.set(`card:${args.id}`, card, { ttl: 3600 });

    return success(card);
  },
});

// ‚úÖ Good - Don't cache, or cache minimal info
const getCreditCardLastFour = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const card = await ctx.database.payments.getCreditCard(args.id);

    // ‚úÖ Only cache safe data
    await ctx.cache.set(`card:${args.id}:last4`, {
      lastFour: card.number.slice(-4),
      expiry: card.expiry,
    }, { ttl: 3600 });

    // Always fetch full data from DB (encrypted)
    const fullCard = await ctx.database.payments.getCreditCard(args.id);

    return success({
      ...fullCard,
      cached: { lastFour: card.number.slice(-4) },
    });
  },
});
```

---

## What's Next?

Great! You've mastered caching. In **Chapter 11**, you'll learn:
- Retry patterns for resilience
- Handling transient failures
- Exponential backoff strategies
- Building robust APIs

Ready to make your API resilient? Let's go! üöÄ

---

## Chapter Recap

You learned:
- ‚úÖ Why caching matters for performance
- Basic caching patterns
- Cache invalidation strategies
- Advanced patterns: stale-while-revalidate, hierarchical cache
- Real-world blog API caching
- Cache key best practices

**Next up:** [Chapter 11: Retry & Resilience](/learn/part-4-production/chapter-11-retry) ‚Üí
