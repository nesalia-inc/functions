---
title: Chapter 5
description: Master mutations - writing data safely
---

# Chapter 5: Mutations - Writing Data

Mutations are how your API writes data. They're type-safe, validated, and designed to handle complex business logic. In this chapter, you'll master mutations.

## What you'll learn in this chapter

- What makes mutations different from queries
- Creating mutations with proper validation
- Transaction patterns
- Mutation composition
- Best practices for data integrity

**Estimated reading time:** 25 minutes

---

## Mutations vs Queries (Quick Recap)

| **Mutations** | **Queries** |
|---------------|-------------|
| **Write** data | **Read** data |
| Not cacheable | Cacheable |
| Can fail | Should be reliable |
| Side effects expected | No side effects |
| Slower (need validation) | Faster (can be prefetched) |

**Simple rule:** If it changes data, use a mutation.

---

## Your First Mutation

### Basic Mutation Structure

```typescript
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.create(args);
    return success(user);
  },
});
```

**Breaking it down:**

1. **`t.mutation`** - Creates a mutation (not a query)
2. **`args`** - Input validation with Zod
3. **`handler`** - The function that runs when mutation is called
4. **`ctx`** - Your context (userId, database, etc.)
5. **`args`** - Validated input
6. **`success()`** - Wrap successful results

---

## Mutation Validation

Mutations validate input just like queries:

```typescript
const createUser = t.mutation({
  args: z.object({
    name: z
      .string()
      .min(2, 'Name must be at least 2 characters')
      .max(100, 'Name must be less than 100 characters'),

    email: z
      .string()
      .email('Invalid email address'),

    age: z
      .number()
      .int('Age must be a whole number')
      .min(18, 'Must be 18 or older')
      .max(120, 'Invalid age'),

    role: z.enum(['user', 'admin']).default('user'),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.create({
      name: args.name,
      email: args.email,
      age: args.age,
      role: args.role,
    });
    return success(user);
  },
});
```

**Validation examples:**
```typescript
// âœ… Valid
await api.createUser({
  name: 'Alice',
  email: 'alice@example.com',
  age: 25,
});

// âŒ ValidationError: Name must be at least 2 characters
await api.createUser({
  name: 'A',
  email: 'alice@example.com',
  age: 25,
});

// âŒ ValidationError: Must be 18 or older
await api.createUser({
  name: 'Alice',
  email: 'alice@example.com',
  age: 15,
});
```

---

## Advanced Mutation Patterns

### Pattern 1: Returning Created Data

```typescript
const createPost = t.mutation({
  args: z.object({
    title: z.string().min(5).max(200),
    content: z.string().min(10),
    published: z.boolean().default(false),
  }),
  handler: async (ctx, args) => {
    // Create the post
    const post = await ctx.database.posts.create({
      title: args.title,
      content: args.content,
      published: args.published,
      authorId: ctx.userId,
      createdAt: new Date(),
    });

    // Return the created post (with generated fields)
    return success({
      id: post.id,
      title: post.title,
      slug: post.slug, // Auto-generated
      createdAt: post.createdAt,
    });
  },
});
```

**Usage:**
```typescript
const result = await api.createPost({
  title: 'Hello World',
  content: 'This is my first post!',
  published: true,
});

if (result.ok) {
  console.log('Created post with ID:', result.value.id);
  console.log('Slug:', result.value.slug);
}
```

### Pattern 2: Update Operations

```typescript
const updateUser = t.mutation({
  args: z.object({
    id: z.number(),
    name: z.string().min(2).optional(),
    email: z.string().email().optional(),
    avatar: z.string().url().optional(),
  }),
  handler: async (ctx, args) => {
    // Check if user exists
    const user = await ctx.database.users.findById(args.id);
    if (!user) {
      throw new Error(`User ${args.id} not found`);
    }

    // Update only provided fields
    const updates: any = {};
    if (args.name !== undefined) updates.name = args.name;
    if (args.email !== undefined) updates.email = args.email;
    if (args.avatar !== undefined) updates.avatar = args.avatar;

    const updated = await ctx.database.users.update(args.id, updates);

    return success(updated);
  },
});
```

### Pattern 3: Delete Operations

```typescript
const deleteUser = t.mutation({
  args: z.object({
    id: z.number(),
    hardDelete: z.boolean().default(false),
  }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.id);
    if (!user) {
      throw new Error(`User ${args.id} not found`);
    }

    if (args.hardDelete) {
      // Permanently delete
      await ctx.database.users.hardDelete(args.id);
    } else {
      // Soft delete
      await ctx.database.users.softDelete(args.id);
    }

    return success({ deleted: true, id: args.id });
  },
});
```

### Pattern 4: Transaction Patterns

```typescript
const transferCredits = t.mutation({
  args: z.object({
    fromUserId: z.number(),
    toUserId: z.number(),
    amount: z.number().positive(),
  }),
  handler: async (ctx, args) => {
    // Use database transaction
    return await ctx.database.transaction(async (trx) => {
      // Check sender balance
      const sender = await trx.users.findById(args.fromUserId);
      if (sender.credits < args.amount) {
        throw new Error('Insufficient credits');
      }

      // Deduct from sender
      await trx.users.update(args.fromUserId, {
        credits: sender.credits - args.amount,
      });

      // Add to receiver
      const receiver = await trx.users.findById(args.toUserId);
      await trx.users.update(args.toUserId, {
        credits: receiver.credits + args.amount,
      });

      // Record transaction
      await trx.transactions.create({
        from: args.fromUserId,
        to: args.toUserId,
        amount: args.amount,
        timestamp: new Date(),
      });

      return success({
        from: args.fromUserId,
        to: args.toUserId,
        amount: args.amount,
        remaining: sender.credits - args.amount,
      });
    });
  },
});
```

> **Good to know:** Transactions ensure that either **all** operations succeed, or **none** do. If any step fails, everything is rolled back.

### Pattern 5: Batch Operations

```typescript
const bulkCreatePosts = t.mutation({
  args: z.object({
    posts: z.array(
      z.object({
        title: z.string().min(5),
        content: z.string().min(10),
      })
    ).min(1).max(100), // Between 1 and 100 posts
  }),
  handler: async (ctx, args) => {
    const results = [];

    for (const post of args.posts) {
      const created = await ctx.database.posts.create({
        ...post,
        authorId: ctx.userId,
        createdAt: new Date(),
      });
      results.push(created);
    }

    return success({
      created: results.length,
      posts: results,
    });
  },
});
```

### Pattern 6: Conditional Mutations

```typescript
const publishPost = t.mutation({
  args: z.object({
    postId: z.number(),
    scheduledAt: z.date().optional(),
  }),
  handler: async (ctx, args) => {
    const post = await ctx.database.posts.findById(args.postId);

    if (!post) {
      throw new Error('Post not found');
    }

    // Check ownership
    if (post.authorId !== ctx.userId) {
      throw new Error('You can only publish your own posts');
    }

    // Check if already published
    if (post.published) {
      throw new Error('Post is already published');
    }

    // Publish now or schedule
    const updateData: any = {
      published: true,
      publishedAt: args.scheduledAt || new Date(),
    };

    const updated = await ctx.database.posts.update(args.postId, updateData);

    // Notify followers
    await ctx.notifications.notifyFollowers(ctx.userId, {
      type: 'new_post',
      postId: post.id,
    });

    return success(updated);
  },
});
```

---

## Mutation Best Practices

### âœ… DO: Validate Everything

```typescript
// âœ… Good - Comprehensive validation
const createOrder = t.mutation({
  args: z.object({
    items: z.array(
      z.object({
        productId: z.number(),
        quantity: z.number().int().positive(),
      })
    ).min(1),
    shippingAddress: z.object({
      street: z.string().min(5),
      city: z.string().min(2),
      country: z.string().length(2),
      postalCode: z.string().regex(/^\d{5}$/),
    }),
    paymentMethod: z.enum(['credit_card', 'paypal', 'bank_transfer']),
  }),
  handler: async (ctx, args) => {
    // All data is validated!
    const order = await ctx.database.orders.create(args);
    return success(order);
  },
});
```

### âœ… DO: Return Meaningful Results

```typescript
// âœ… Good - Returns useful data
const createComment = t.mutation({
  args: z.object({
    postId: z.number(),
    content: z.string().min(1).max(1000),
  }),
  handler: async (ctx, args) => {
    const comment = await ctx.database.comments.create({
      postId: args.postId,
      content: args.content,
      authorId: ctx.userId,
      createdAt: new Date(),
    });

    return success({
      id: comment.id,
      content: comment.content,
      createdAt: comment.createdAt,
      // Include the comment count
      postCommentCount: await ctx.database.comments.countByPost(args.postId),
    });
  },
});
```

### âœ… DO: Use Transactions for Multi-Step Operations

```typescript
// âœ… Good - Transaction ensures consistency
const createOrderAndCharge = t.mutation({
  args: z.object({
    items: z.array(z.object({
      productId: z.number(),
      quantity: z.number(),
    })),
    paymentMethodId: z.string(),
  }),
  handler: async (ctx, args) => {
    return await ctx.database.transaction(async (trx) => {
      // 1. Create order
      const order = await trx.orders.create({
        userId: ctx.userId,
        items: args.items,
        status: 'pending',
      });

      // 2. Calculate total
      const total = await calculateTotal(args.items);

      // 3. Charge payment
      const charge = await trx.payments.charge({
        paymentMethodId: args.paymentMethodId,
        amount: total,
        orderId: order.id,
      });

      // 4. Update order status
      await trx.orders.update(order.id, {
        status: 'paid',
        paymentId: charge.id,
      });

      return success({ orderId: order.id, status: 'paid' });
    });
  },
});
```

### âŒ DON'T: Ignore Errors

```typescript
// âŒ Bad - Errors are silently ignored
const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    try {
      const user = await ctx.database.users.create(args);
      return success(user);
    } catch (error) {
      // âŒ Just returns success even if it failed!
      return success({ id: 0, name: args.name });
    }
  },
});

// âœ… Good - Handle errors properly
const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    try {
      const user = await ctx.database.users.create(args);
      return success(user);
    } catch (error) {
      // Log the error
      ctx.logger.error('Failed to create user', { args, error });

      // Re-throw with context
      if (error.code === 'DUPLICATE_EMAIL') {
        throw new Error('Email already exists');
      }
      throw error;
    }
  },
});
```

### âŒ DON'T: Put Business Logic in Frontend

```typescript
// âŒ Bad - Business logic in frontend
const handleCreateOrder = async () => {
  const items = getItems();

  // âŒ This logic should be in the API!
  const total = items.reduce((sum, item) => sum + item.price, 0);
  const tax = total * 0.1;
  const shipping = items.length > 5 ? 0 : 10;
  const final = total + tax + shipping;

  await api.createOrder({ items, total: final });
};

// âœ… Good - Business logic in API
const createOrder = t.mutation({
  args: z.object({
    items: z.array(z.object({
      productId: z.number(),
      quantity: z.number(),
    })),
  }),
  handler: async (ctx, args) => {
    // âœ… Business logic in the mutation
    const total = args.items.reduce((sum, item) => {
      const product = await ctx.database.products.findById(item.productId);
      return sum + (product.price * item.quantity);
    }, 0);

    const tax = total * 0.1; // 10% tax
    const shipping = args.items.length > 5 ? 0 : 10;
    const final = total + tax + shipping;

    const order = await ctx.database.orders.create({
      userId: ctx.userId,
      items: args.items,
      total: final,
    });

    return success(order);
  },
});
```

---

## Real-World Example

Let's build a complete user registration flow:

```typescript
const registerUser = t.mutation({
  args: z.object({
    email: z.string().email(),
    password: z.string().min(8, 'Password must be at least 8 characters'),
    name: z.string().min(2).max(100),
    acceptTerms: z.literal(true, {
      errorMap: () => ({ message: 'You must accept the terms' }),
    }),
  }),
  handler: async (ctx, args) => {
    // 1. Check if email already exists
    const existing = await ctx.database.users.findByEmail(args.email);
    if (existing) {
      throw new Error('Email already registered');
    }

    // 2. Hash password
    const hashedPassword = await ctx.auth.hashPassword(args.password);

    // 3. Create user
    const user = await ctx.database.users.create({
      email: args.email,
      password: hashedPassword,
      name: args.name,
      role: 'user',
      createdAt: new Date(),
    });

    // 4. Create default settings
    await ctx.database.settings.create({
      userId: user.id,
      emailNotifications: true,
      theme: 'light',
    });

    // 5. Generate verification token
    const token = ctx.auth.generateVerificationToken(user.id);

    // 6. Send verification email
    await ctx.email.send({
      to: user.email,
      subject: 'Verify your email',
      template: 'verification',
      data: { token },
    });

    // 7. Log registration
    ctx.logger.info('User registered', { userId: user.id, email: user.email });

    // 8. Return user (without password)
    const { password, ...userWithoutPassword } = user;
    return success(userWithoutPassword);
  },
});
```

**This mutation:**
- âœ… Validates all input
- âœ… Checks for duplicates
- âœ… Hashes passwords
- âœ… Creates user
- âœ… Sets up defaults
- âœ… Sends verification email
- âœ… Logs activity
- âœ… Returns safe data

---

## What's Next?

You've mastered mutations! In **Chapter 6**, you'll learn:
- How to organize endpoints with routers
- Nested routing patterns
- API composition
- Large-scale API structure

Ready to organize your API? Let's go! ðŸš€

---

## Chapter Recap

You learned:
- âœ… How mutations differ from queries
- âœ… Creating mutations with validation
- âœ… Advanced patterns: updates, deletes, transactions, batches
- âœ… Best practices for data integrity
- âœ… Real-world registration example

**Next up:** [Chapter 6: Routers](/learn/part-2-core-concepts/chapter-6-routers) â†’
