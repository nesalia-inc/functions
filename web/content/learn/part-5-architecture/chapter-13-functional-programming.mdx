---
title: Chapter 13
description: Understand functional programming principles
---

# Chapter 13: Functional Programming Principles

DeesseJS Functions is built on functional programming principles. Understanding these principles will help you write cleaner, more maintainable code.

## What you'll learn in this chapter

- Why functional programming matters
- Core FP principles in DeesseJS Functions
- Practical FP patterns
- Avoiding common anti-patterns
- Thinking functionally

**Estimated reading time:** 25 minutes

---

## Why Functional Programming?

Functional programming (FP) emphasizes:
- **Pure functions** - Same input = same output, no side effects
- **Immutability** - Data never changes, we create new data
- **Composition** - Small functions combined into complex ones
- **First-class functions** - Functions can be passed as data

### Benefits for API Development

```typescript
// ‚ùå Imperative style - harder to reason about
let userId = 'user-123';
const user = await db.users.findById(userId);
user.processed = true;
await db.users.save(user);

// ‚úÖ Functional style - predictable and testable
const processedUser = await pipe(
  await db.users.findById('user-123'),
  transformUser,
  await db.users.save
);
```

---

## Core Principle 1: No Classes

### The Problem with Classes

Classes mix data and behavior, making code harder to test and reuse:

```typescript
// ‚ùå Class-based - mixing concerns
class UserService {
  constructor(private db: Database) {}

  async getUser(id: number) {
    const user = await this.db.users.findById(id);
    return user.process();
  }

  async updateUser(id: number, data: any) {
    const user = await this.db.users.findById(id);
    user.update(data);
    return this.db.users.save(user);
  }
}
```

### The Functional Solution

```typescript
// ‚úÖ Functional - separation of concerns
const getUser = (db: Database) => async (id: number) => {
  const user = await db.users.findById(id);
  return transformUser(user);
};

const updateUser = (db: Database) => async (id: number, data: any) => {
  const user = await db.users.findById(id);
  const updated = { ...user, ...data };
  return db.users.save(updated);
};

// Usage
const userService = {
  get: getUser(database),
  update: updateUser(database),
};

await userService.get(database)(123);
```

**In DeesseJS Functions:**

```typescript
// ‚úÖ Following the principle - pure functions, no classes
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.findById(args.id));
  },
});
```

---

## Core Principle 2: No Interfaces

### The Problem with Interfaces

Interfaces in TypeScript create nominal typing that can cause issues:

```typescript
// ‚ùå Interface - nominal typing
interface User {
  id: number;
  name: string;
}

interface Post {
  id: number;
  author: User;
}

// Two User types with same shape are incompatible!
interface IUser {
  id: number;
  name: string;
}

function processUser(user: User) {
  // ...
}

processUser(iUser); // ‚ùå Type error!
```

### The Solution: Type Aliases

```typescript
// ‚úÖ Type alias - structural typing
type User = {
  id: number;
  name: string;
};

type Post = {
  id: number;
  author: User;
};

// Compatible if structures match
type IUser = {
  id: number;
  name: string;
};

function processUser(user: User) {
  // ...
}

processUser(iUser as User); // ‚úÖ Works!
```

**In DeesseJS Functions:**

```typescript
// ‚úÖ All type definitions use aliases
type Context = {
  userId: string;
  database: Database;
};
```

---

## Core Principle 3: Const Functions Only

### The Problem with `function` Keyword

The `function` keyword has inconsistent behavior:

```typescript
// ‚ùå Inconsistent behavior
function getUser() { }
const getUser = () => { };

getUser.name; // "getUser"
getUser.displayName; // "getUser"
constGetUser.displayName; // undefined
```

### The Solution: Arrow Functions

```typescript
// ‚úÖ Consistent behavior
const getUser = () => { };

getUser.name; // undefined
const userGetter = getUser;
userGetter.name; // undefined

// With name
const getUserWithName = () => { };
getUserWithName.name; // "getUserWithName"
```

**In DeesseJS Functions:**

```typescript
// ‚úÖ All functions are arrow functions
export const defineContext = <T extends ContextShape>(context: T) => {
  // ...
};

export const t = {
  query: <A, R>(definition: QueryDefinition<A, R>) => {
    // ...
  },
};
```

---

## Core Principle 4: Immutability

### The Problem with Mutation

Mutation makes code harder to reason about:

```typescript
// ‚ùå Mutation - hard to track changes
const updateUser = (user: User, data: any) => {
  user.name = data.name; // ‚ùå Mutates original
  user.email = data.email;
  return user;
};

const user = { id: 1, name: 'Alice', email: 'alice@example.com' };
updateUser(user, { name: 'Bob' });

console.log(user.name); // 'Bob' - ‚ùå Changed unexpectedly!
```

### The Solution: Immutable Updates

```typescript
// ‚úÖ Immutable - original unchanged
const updateUser = (user: User, data: Partial<User>) => {
  return {
    ...user,
    ...data,
  };
};

const user = { id: 1, name: 'Alice', email: 'alice@example.com' };
const updated = updateUser(user, { name: 'Bob' });

console.log(user.name); // 'Alice' - ‚úÖ Original preserved!
console.log(updated.name); // 'Bob'
```

**In DeesseJS Functions:**

```typescript
// ‚úÖ All operations are immutable by design
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    // ‚úÖ Return new data, never mutate context
    return success({ ...user });
  },
});
```

---

## Practical FP Patterns

### Pattern 1: Function Composition

```typescript
// Compose small functions into complex ones
type User = { id: number; name: string; };

const trimName = (user: User) => ({
  ...user,
  name: user.name.trim(),
});

const capitalizeName = (user: User) => ({
  ...user,
  name: user.name.charAt(0).toUpperCase() + user.name.slice(1),
});

const addTitle = (title: string) => <T extends object>(obj: T) => ({
  ...obj,
  title,
});

// Compose them
const processUser = (user: User) =>
  pipe(
    trimName,
    capitalizeName,
    addTitle('Mr.'),
  );

console.log(processUser({ id: 1, name: 'alice' }));
// { id: 1, name: 'Alice', title: 'Mr.' }
```

### Pattern 2: Currying

```typescript
// Curried functions for partial application
const createQuery = <T extends z.ZodType>(args: T) =>
  <R>(handler: QueryHandler<T, R>) =>
    query({ args, handler });

// Usage
const getUserById = createQuery(
  z.object({ id: z.number() })
)((ctx: Context, args: { id: number }) => {
  return success(ctx.database.users.findById(args.id));
});
```

### Pattern 3: Option/Maybe Pattern

```typescript
// Return undefined for "not found"
const findUser = async (id: number): Promise<User | undefined> => {
  const user = await database.users.findById(id);
  return user ?? undefined; // or null
};

// Handle with optional chaining
const userEmail = await findUser(123)?.email;
```

### Pattern 4: Pipeline Pattern

```typescript
import { pipe } from 'lodash/fp';

// Define operations
const operations = pipe(
  validateInput,
  checkPermissions,
  transformData,
  saveToDatabase,
  sendNotification,
);

// Use in mutation
const processData = t.mutation({
  args: z.object({ data: z.any() }),
  handler: async (ctx, args) => {
    const result = await operations(args.data);
    return success(result);
  },
});
```

---

## Common Anti-Patterns

### ‚ùå Anti-Pattern 1: Side Effects in Pure Functions

```typescript
// ‚ùå Bad - Side effect in pure function
const getUser = (id: number) => {
  console.log('Fetching user', id); // ‚ùå Side effect!
  return fetchUser(id);
};

// ‚úÖ Good - Pure function
const getUser = (id: number) => {
  return fetchUser(id);
};

// Log side effects at the call site
const logAndFetch = (id: number) => {
  console.log('Fetching user', id);
  return getUser(id);
};
```

### ‚ùå Anti-Pattern 2: Mutating Arguments

```typescript
// ‚ùå Bad - Mutates argument
const processArray = (items: any[]) => {
  items.push('new-item'); // ‚ùå Mutation!
  return items;
};

// ‚úÖ Good - Creates new array
const processArray = (items: any[]) => {
  return [...items, 'new-item'];
};
```

### ‚ùå Anti-Pattern 3: Hidden Dependencies

```typescript
// ‚ùå Bad - Hidden dependency on global
const getUser = () => {
  return database.users.findById(123); // ‚ùå Hidden global
};

// ‚úÖ Good - Explicit dependencies
const getUser = (db: Database) => async (id: number) => {
  return db.users.findById(id);
};

// Usage
const user = await getUser(database)(123);
```

---

## Real-World FP Example

Here's a complex data pipeline using functional patterns:

```typescript
import { pipe } from 'lodash/fp';
import { success, failure, cause } from '@deessejs/functions';

// ===========================
// Pure transformations
// ===========================

const sanitizeInput = (input: any) => ({
  ...input,
  name: input.name?.trim() || '',
  email: input.email?.toLowerCase().trim() || '',
});

const validateInput = (input: any) => {
  const errors = [];

  if (input.name.length < 2) {
    errors.push('Name must be at least 2 characters');
  }

  if (!input.email.includes('@')) {
    errors.push('Invalid email address');
  }

  if (errors.length > 0) {
    return failure(
      cause({
        name: 'ValidationError',
        message: 'Validation failed',
        errors,
      })
    );
  }

  return success(input);
};

const enrichWithMetadata = (input: any) => ({
  ...input,
  createdAt: new Date(),
  updatedAt: new Date(),
  version: 1,
});

// ===========================
// Data processing pipeline
// ===========================

const processNewUser = pipe(
  sanitizeInput,
  validateInput,
  enrichWithMetadata,
);

// Use in mutation
const createUser = t.mutation({
  args: z.object({
    name: z.string(),
    email: z.string(),
  }),
  handler: async (ctx, args) => {
    const result = processNewUser(args);

    if (!result.ok) {
      return failure(result.error);
    }

    const user = await ctx.database.users.create(result.value);

    return success(user);
  },
});
```

---

## What's Next?

Excellent work understanding functional programming! In this **final chapter**, you'll learn:
- How to migrate from other frameworks
- Migration strategies
- Common migration patterns
- Best practices for migration

Ready for the final chapter? Let's finish strong! üí™

---

## Chapter Recap

You learned:
- ‚úÖ Why functional programming matters for API development
- Core principles: no classes, no interfaces, const functions only, immutability
- Practical FP patterns: composition, currying, pipelines
- Common anti-patterns to avoid
- Real-world data pipeline example

**Next up:** [Chapter 14: Migration](/learn/part-5-architecture/chapter-14-migration) ‚Üí
