---
title: Chapter 8
description: Hook into the lifecycle with lifecycle hooks
---

# Chapter 8: Lifecycle Hooks - Middleware & Interceptors

Lifecycle hooks let you run code at specific points during request processing. Think of them as middleware that can transform inputs, log actions, or handle errors - all while maintaining type safety.

## What you'll learn in this chapter

- What lifecycle hooks are and when they run
- The three hook types: beforeInvoke, onSuccess, onError
- Creating reusable middleware with hooks
- Real-world hook patterns
- Performance considerations

**Estimated reading time:** 25 minutes

---

## What are Lifecycle Hooks?

**Lifecycle hooks** are functions that run at specific points during the execution of a query or mutation:

```
Request â†’ beforeInvoke â†’ handler â†’ onSuccess â†’ Response
                  â†“ (error) â†’ onError â†’ Response
```

Each hook serves a specific purpose:

- **beforeInvoke** - Transform input before the handler runs
- **onSuccess** - Run after successful completion
- **onError** - Handle errors gracefully

---

## Hook Execution Order

### Successful Request

```
1. Request received
2. Validation (Zod)
3. beforeInvoke hook
4. Handler execution
5. onSuccess hook
6. Response returned
```

### Failed Request

```
1. Request received
2. Validation (Zod)
3. beforeInvoke hook
4. Handler execution â†’ ERROR
5. onError hook
6. Error response returned
```

---

## beforeInvoke Hook

The `beforeInvoke` hook runs **before** your handler, after validation:

```typescript
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.create(args));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Log the attempt
    ctx.logger.info('Creating user', { email: args.email });

    // Check if email already exists
    const existing = await ctx.database.users.findByEmail(args.email);
    if (existing) {
      throw new Error('Email already exists');
    }

    // Transform args
    args.name = args.name.trim();
  });
```

> **Good to know:** You can modify `args` in `beforeInvoke` - changes affect the handler.

### Use Cases for beforeInvoke

**1. Pre-flight Validation**

```typescript
const transferCredits = t.mutation({
  args: z.object({
    fromUserId: z.number(),
    toUserId: z.number(),
    amount: z.number().positive(),
  }),
  handler: async (ctx, args) => {
    // Business logic
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Check sender balance before running handler
    const sender = await ctx.database.users.findById(args.fromUserId);

    if (sender.credits < args.amount) {
      throw new Error('Insufficient credits');
    }
  });
```

**2. Input Transformation**

```typescript
const createPost = t.mutation({
  args: z.object({
    title: z.string(),
    content: z.string(),
    tags: z.array(z.string()),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.create(args));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Sanitize and normalize input
    args.title = args.title.trim();
    args.content = args.content.trim();
    args.tags = args.tags.map(tag => tag.toLowerCase().trim());
  });
```

**3. Audit Logging**

```typescript
const deleteUser = t.mutation({
  args: z.object({
    userId: z.number(),
    reason: z.string(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.delete(args.userId));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // Log before destructive action
    await ctx.database.auditLog.create({
      action: 'DELETE_USER',
      userId: ctx.userId,
      targetUserId: args.userId,
      reason: args.reason,
      timestamp: new Date(),
    });
  });
```

---

## onSuccess Hook

The `onSuccess` hook runs **after** your handler completes successfully:

```typescript
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.create(args));
  },
})
  .onSuccess(async (ctx, args, data) => {
    // data = the result from the handler

    // Send welcome email
    await ctx.email.send({
      to: data.email,
      template: 'welcome',
      data: { name: data.name },
    });

    // Track signup
    await ctx.analytics.track('user_registered', {
      userId: data.id,
      email: data.email,
    });
  });
```

> **Good to know:** `data` is the value wrapped in `success()` in your handler.

### Use Cases for onSuccess

**1. Side Effects**

```typescript
const publishPost = t.mutation({
  args: z.object({
    postId: z.number(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.publish(args.postId));
  },
})
  .onSuccess(async (ctx, args, data) => {
    // Notify followers
    await ctx.notifications.notifyFollowers(ctx.userId, {
      type: 'new_post',
      postId: data.id,
      title: data.title,
    });

    // Invalidate cache
    await ctx.cache.delete(`posts:${data.id}`);
    await ctx.cache.delete('posts:list');
  });
```

**2. Cache Invalidation**

```typescript
const updatePost = t.mutation({
  args: z.object({
    id: z.number(),
    title: z.string().optional(),
    content: z.string().optional(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.update(args.id, args));
  },
})
  .onSuccess(async (ctx, args, data) => {
    // Invalidate all caches related to this post
    await Promise.all([
      ctx.cache.delete(`post:${data.id}`),
      ctx.cache.delete(`posts:author:${data.authorId}`),
      ctx.cache.delete('posts:list'),
    ]);
  });
```

**3. Webhooks**

```typescript
const paymentReceived = t.mutation({
  args: z.object({
    paymentId: z.string(),
    amount: z.number(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.payments.record(args));
  },
})
  .onSuccess(async (ctx, args, data) => {
    // Trigger webhook
    await ctx.webhooks.send('payment.success', {
      paymentId: data.id,
      amount: data.amount,
      timestamp: new Date(),
    });
  });
```

---

## onError Hook

The `onError` hook runs when your handler throws an error:

```typescript
const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.create(args));
  },
})
  .onError(async (ctx, args, error) => {
    // Log the error
    ctx.logger.error('Failed to create user', {
      args,
      error: error.message,
      stack: error.stack,
    });

    // Send alert to monitoring
    await ctx.monitoring.alert({
      severity: 'error',
      message: 'User creation failed',
      error: error.message,
    });
  });
```

> **Good to know:** If `onError` throws, the original error is replaced by the new error.

### Use Cases for onError

**1. Error Logging**

```typescript
const processPayment = t.mutation({
  args: z.object({
    userId: z.number(),
    amount: z.number(),
    paymentMethodId: z.string(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.payments.charge(args));
  },
})
  .onError(async (ctx, args, error) => {
    // Log to database
    await ctx.database.errorLog.create({
      operation: 'processPayment',
      userId: ctx.userId,
      args,
      error: error.message,
      stack: error.stack,
      timestamp: new Date(),
    });

    // Log to external service
    await ctx.sentry.captureException(error, {
      tags: { operation: 'processPayment' },
      extra: { args },
    });
  });
```

**2. Graceful Degradation**

```typescript
const sendNotification = t.mutation({
  args: z.object({
    userId: z.number(),
    message: z.string(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.notifications.send(args));
  },
})
  .onError(async (ctx, args, error) => {
    // Email failed, try fallback
    if (error.message.includes('email')) {
      await ctx.notifications.create({
        userId: args.userId,
        message: args.message,
        method: 'in-app',
      });
    }
  });
```

**3. Automatic Retry**

```typescript
const callExternalAPI = t.mutation({
  args: z.object({
    endpoint: z.string(),
    data: z.any(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.externalAPI.post(args.endpoint, args.data));
  },
})
  .onError(async (ctx, args, error) => {
    // Retry once on network errors
    if (error.message.includes('ECONNREFUSED')) {
      ctx.logger.info('Retrying request...');
      await ctx.externalAPI.post(args.endpoint, args.data);
    }
  });
```

---

## Combining Hooks

You can chain multiple hooks:

```typescript
const updateUser = t.mutation({
  args: z.object({
    id: z.number(),
    name: z.string().min(2).optional(),
    email: z.string().email().optional(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.update(args.id, args));
  },
})
  .beforeInvoke(async (ctx, args) => {
    ctx.logger.info('Updating user', { id: args.id });
  })
  .onSuccess(async (ctx, args, data) => {
    ctx.logger.info('User updated', { id: data.id });
    await ctx.cache.delete(`user:${data.id}`);
  })
  .onError(async (ctx, args, error) => {
    ctx.logger.error('Failed to update user', { id: args.id, error });
  });
```

---

## Creating Reusable Hook Patterns

### Pattern 1: Logging Hook

```typescript
function withLogging(operation: string) {
  return {
    beforeInvoke: async (ctx: Context, args: any) => {
      ctx.logger.info(`${operation} started`, { args });
    },
    onSuccess: async (ctx: Context, args: any, data: any) => {
      ctx.logger.info(`${operation} succeeded`, { args, result: data });
    },
    onError: async (ctx: Context, args: any, error: Error) => {
      ctx.logger.error(`${operation} failed`, { args, error });
    },
  };
}

const createUser = t.mutation({
  args: z.object({ name: z.string(), email: z.string().email() }),
  handler: async (ctx, args) => {
    return success(await ctx.database.users.create(args));
  },
})
  .beforeInvoke(withLogging('createUser').beforeInvoke)
  .onSuccess(withLogging('createUser').onSuccess)
  .onError(withLogging('createUser').onError);
```

### Pattern 2: Timing Hook

```typescript
function withTiming(operation: string) {
  return {
    beforeInvoke: async (ctx: Context, args: any) => {
      ctx.startTime = Date.now();
    },
    onSuccess: async (ctx: Context, args: any, data: any) => {
      const duration = Date.now() - ctx.startTime;
      ctx.logger.info(`${operation} completed in ${duration}ms`);
    },
  };
}
```

### Pattern 3: Cache Invalidation Hook

```typescript
function invalidateCache(keys: string[]) {
  return {
    onSuccess: async (ctx: Context, args: any, data: any) => {
      await Promise.all(
        keys.map(key => ctx.cache.delete(key))
      );
    },
  };
}

const updatePost = t.mutation({
  args: z.object({ id: z.number(), title: z.string() }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.update(args.id, args));
  },
})
  .onSuccess(invalidateCache([`post:${args.id}`, 'posts:list']).onSuccess);
```

---

## Real-World Example

Here's a complete example with all hook types:

```typescript
const publishPost = t.mutation({
  args: z.object({
    postId: z.number(),
    scheduledAt: z.date().optional(),
  }),
  handler: async (ctx, args) => {
    return success(await ctx.database.posts.publish(args.postId, args.scheduledAt));
  },
})
  .beforeInvoke(async (ctx, args) => {
    // 1. Verify post exists
    const post = await ctx.database.posts.findById(args.postId);
    if (!post) {
      throw new Error('Post not found');
    }

    // 2. Verify ownership
    if (post.authorId !== ctx.userId) {
      throw new Error('You can only publish your own posts');
    }

    // 3. Check if already published
    if (post.published) {
      throw new Error('Post is already published');
    }

    // 4. Log the attempt
    ctx.logger.info('Attempting to publish post', {
      postId: args.postId,
      userId: ctx.userId,
    });
  })
  .onSuccess(async (ctx, args, data) => {
    // 1. Invalidate caches
    await ctx.cache.delete(`post:${data.id}`);
    await ctx.cache.delete(`posts:author:${ctx.userId}`);
    await ctx.cache.delete('posts:list');

    // 2. Notify followers
    await ctx.notifications.notifyFollowers(ctx.userId, {
      type: 'new_post',
      postId: data.id,
      title: data.title,
      slug: data.slug,
    });

    // 3. Track analytics
    await ctx.analytics.track('post_published', {
      postId: data.id,
      authorId: ctx.userId,
    });

    // 4. Log success
    ctx.logger.info('Post published successfully', {
      postId: data.id,
      slug: data.slug,
    });
  })
  .onError(async (ctx, args, error) => {
    // 1. Log error
    ctx.logger.error('Failed to publish post', {
      postId: args.postId,
      error: error.message,
      stack: error.stack,
    });

    // 2. Send alert
    await ctx.monitoring.alert({
      severity: 'error',
      message: 'Post publication failed',
      postId: args.postId,
      error: error.message,
    });
  });
```

---

## Hook Best Practices

### âœ… DO: Keep Hooks Fast

```typescript
// âœ… Good - Fast hook
.beforeInvoke(async (ctx, args) => {
  args.name = args.name.trim(); // Quick operation
});

// âŒ Bad - Slow hook
.beforeInvoke(async (ctx, args) => {
  // This makes every request slow!
  await ctx.analytics.track('request_started', { args });
  await ctx.database.auditLog.create({ args });
  await ctx.email.sendNotification({ ... });
});
```

### âœ… DO: Use Hooks for Cross-Cutting Concerns

```typescript
// âœ… Good - Logging applies to all operations
const logOperation = (operation: string) => ({
  beforeInvoke: async (ctx, args) => {
    ctx.logger.info(`${operation} started`, { args });
  },
  onSuccess: async (ctx, args, data) => {
    ctx.logger.info(`${operation} succeeded`);
  },
  onError: async (ctx, args, error) => {
    ctx.logger.error(`${operation} failed`, { error });
  },
});
```

### âŒ DON'T: Modify Handler Return in Hooks

```typescript
// âŒ Bad - Trying to change the return value
.onSuccess(async (ctx, args, data) => {
  // âŒ This doesn't work!
  data.extraField = 'value';
});

// âœ… Good - Use side effects instead
.onSuccess(async (ctx, args, data) => {
  await ctx.database.addExtraField(data.id, 'value');
});
```

---

## What's Next?

You've mastered lifecycle hooks! In **Chapter 9**, you'll learn:
- Advanced error handling patterns
- Creating custom error types
- Outcome types vs Exceptions
- Real-world error strategies

Ready to handle errors like a pro? Let's go! ðŸš€

---

## Chapter Recap

You learned:
- âœ… What lifecycle hooks are and when they run
- âœ… Using beforeInvoke, onSuccess, onError
- âœ… Creating reusable middleware patterns
- âœ… Real-world hook examples
- âœ… Best practices for performant hooks

**Next up:** [Chapter 9: Error Handling](/learn/part-3-advanced-patterns/chapter-9-error-handling) â†’
