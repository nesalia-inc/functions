---
title: Chapter 9
description: Master error handling patterns
---

# Chapter 9: Error Handling - Fail Gracefully

Robust applications handle errors gracefully. In this chapter, you'll learn advanced error handling patterns that keep your API reliable and your users informed.

## What you'll learn in this chapter

- Outcome types vs exceptions
- Creating custom error types
- Structured error responses
- Error handling best practices
- Real-world error strategies

**Estimated reading time:** 30 minutes

---

## Two Error Handling Approaches

### Approach 1: Exceptions (Traditional)

```typescript
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.id);

    // âŒ Throw error if not found
    if (!user) {
      throw new Error('User not found');
    }

    return success(user);
  },
});
```

**Pros:**
- Simple and familiar
- Stops execution immediately
- Built-in error stack traces

**Cons:**
- Unstructured errors
- Hard to distinguish error types
- Can't be serialized across network boundaries easily

### Approach 2: Outcome Types (Recommended)

```typescript
import { success, failure, Causes, successOutcome, failureOutcome } from '@deessejs/functions';

const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.id);

    // âœ… Return failure outcome
    if (!user) {
      return failureOutcome(
        Causes.notFound(args.id, 'User')
      );
    }

    return successOutcome(user);
  },
});
```

**Pros:**
- Structured, type-safe errors
- Can be serialized over network
- Easy to pattern match on error type
- Better for API responses

**Cons:**
- More verbose
- Requires explicit error handling

---

## Using Outcome Types

### Basic Success and Failure

```typescript
import { success, failure } from '@deessejs/functions';

const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
  handler: async (ctx, args) => {
    try {
      const user = await ctx.database.users.create(args);
      return success(user);
    } catch (error) {
      if (error.code === 'DUPLICATE_EMAIL') {
        return failure(new Error('Email already exists'));
      }
      return failure(error);
    }
  },
});
```

### Using Outcome Results

```typescript
const result = await api.createUser({
  name: 'Alice',
  email: 'alice@example.com',
});

if (result.ok) {
  // Success
  console.log('Created user:', result.value);
} else {
  // Failure
  console.error('Error:', result.error.message);

  // Pattern match on error type
  if (result.error.name === 'DuplicateEmail') {
    console.log('Please use a different email');
  }
}
```

---

## Creating Custom Error Types

### Define Error Schemas

```typescript
import { cause, Causes } from '@deessejs/functions';

// Predefined error causes
const Errors = {
  notFound: (id: number, resource: string) =>
    Causes.notFound(id, resource),

  unauthorized: (reason: string) =>
    Causes.unauthorized(reason),

  forbidden: (reason: string) =>
    Causes.forbidden(reason),

  validation: (field: string, message: string) =>
    Causes.validation(field, message),

  conflict: (reason: string) =>
    Causes.conflict(reason),

  rateLimit: () =>
    Causes.rateLimit(),

  internal: (message: string) =>
    Causes.internal(message),
};
```

### Using Custom Errors

```typescript
const deleteUser = t.mutation({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.id);

    if (!user) {
      return failureOutcome(
        Errors.notFound(args.id, 'User')
      );
    }

    if (args.id === ctx.userId) {
      return failureOutcome(
        Errors.forbidden('Cannot delete yourself')
      );
    }

    return success(await ctx.database.users.delete(args.id));
  },
});
```

---

## Structured Error Responses

### Error Response Format

```typescript
const result = await api.deleteUser({ id: 1 });

if (!result.ok) {
  console.log({
    name: result.error.name,        // Error type
    message: result.error.message,    // Human-readable message
    cause: result.error.cause,       // Structured cause data
    stack: result.error.stack,       // Stack trace (dev only)
  });
}
```

### Example Error Response

```typescript
// Not found error
{
  ok: false,
  error: {
    name: 'NotFound',
    message: 'User 123 not found',
    cause: {
      type: 'not_found',
      resourceId: 123,
      resourceType: 'User'
    }
  }
}

// Validation error
{
  ok: false,
  error: {
    name: 'ValidationError',
    message: 'Validation failed',
    cause: {
      type: 'validation',
      field: 'email',
      issue: 'Invalid email format'
    }
  }
}

// Forbidden error
{
  ok: false,
  error: {
    name: 'Forbidden',
    message: 'Cannot delete yourself',
    cause: {
      type: 'forbidden',
      reason: 'Self-deletion not allowed'
    }
  }
}
```

---

## Advanced Error Patterns

### Pattern 1: Domain-Specific Errors

```typescript
const UserErrors = {
  duplicateEmail: (email: string) =>
    cause({
      name: 'DuplicateEmail',
      message: `Email ${email} is already registered`,
      email,
    }),

  underageUser: (age: number, minimum: number) =>
    cause({
      name: 'UnderageUser',
      message: `Must be at least ${minimum} years old`,
      currentAge: age,
      requiredAge: minimum,
    }),

  lockedAccount: () =>
    cause({
      name: 'LockedAccount',
      message: 'Account is locked',
      supportUrl: '/support/unlock',
    }),
};

const createUser = t.mutation({
  args: z.object({
    name: z.string().min(2),
    email: z.string().email(),
    age: z.number(),
  }),
  handler: async (ctx, args) => {
    const existing = await ctx.database.users.findByEmail(args.email);
    if (existing) {
      return failureOutcome(UserErrors.duplicateEmail(args.email));
    }

    if (args.age < 18) {
      return failureOutcome(UserErrors.underageUser(args.age, 18));
    }

    const user = await ctx.database.users.create(args);
    return success(user);
  },
});
```

### Pattern 2: Error Enrichment

```typescript
const createPost = t.mutation({
  args: z.object({
    title: z.string().min(5),
    content: z.string().min(10),
  }),
  handler: async (ctx, args) => {
    try {
      return success(await ctx.database.posts.create({
        ...args,
        authorId: ctx.userId,
      }));
    } catch (error) {
      // Enrich error with context
      if (error.code === 'DUPLICATE_TITLE') {
        return failure(
          cause({
            name: 'DuplicateTitle',
            message: 'A post with this title already exists',
            title: args.title,
            userId: ctx.userId,
            suggestions: [
              `Try "${args.title} (${ctx.userId})"`,
              `Try "${args.title} - ${new Date().getFullYear()}"`,
            ],
          })
        );
      }
      return failure(error);
    }
  },
});
```

### Pattern 3: Retryable Errors

```typescript
import { RetryableError } from '@deessejs/functions';

const fetchFromAPI = t.query({
  args: z.object({
    endpoint: z.string(),
  }),
  handler: async (ctx, args) => {
    try {
      const response = await fetch(args.endpoint);
      return success(await response.json());
    } catch (error) {
      // Mark as retryable
      if (error.code === 'ECONNREFUSED') {
        return failure(new RetryableError('API unavailable', { retryAfter: 1000 }));
      }
      return failure(error);
    }
  },
});
```

---

## Error Handling Best Practices

### âœ… DO: Use Outcome Types for APIs

```typescript
// âœ… Good - Structured errors
const getUser = t.query({
  args: z.object({ id: z.number() }),
  handler: async (ctx, args) => {
    const user = await ctx.database.users.findById(args.id);
    if (!user) {
      return failureOutcome(
        Errors.notFound(args.id, 'User')
      );
    }
    return successOutcome(user);
  },
});
```

### âœ… DO: Provide Actionable Error Messages

```typescript
// âœ… Good - Clear, actionable messages
return failure(
  cause({
    name: 'ValidationError',
    message: 'Email is required and must be valid',
    field: 'email',
    examples: ['user@example.com', 'alice@domain.com'],
    helpUrl: '/docs/email-format',
  })
);
```

### âœ… DO: Include Error Context

```typescript
// âœ… Good - Rich error context
return failure(
  cause({
    name: 'RateLimitExceeded',
    message: 'Too many requests',
    limit: 100,
    window: '1 minute',
    retryAfter: 45, // seconds
    docs: '/docs/rate-limits',
  })
);
```

### âŒ DON'T: Expose Sensitive Information

```typescript
// âŒ Bad - Leaks implementation details
return failure({
  name: 'DatabaseError',
  message: 'Query failed: SELECT * FROM users WHERE id = 1',
  stack: error.stack,
  config: { databaseUrl: 'postgresql://...' },
});

// âœ… Good - Generic message, logs details separately
ctx.logger.error('Database query failed', { error, query });

return failure(
  Errors.internal('Failed to fetch user')
);
```

### âŒ DON'T: Use Generic Errors

```typescript
// âŒ Bad - Not helpful
return failure(new Error('An error occurred'));

// âŒ Bad - Just a number
return failure(new Error('Error 500'));

// âœ… Good - Descriptive
return failure(
  Errors.notFound(userId, 'User')
);
```

---

## Real-World Error Handling Example

Here's a complete error handling strategy for a payment system:

```typescript
import { success, failure, cause, Errors } from '@deessejs/functions';

const PaymentErrors = {
  insufficientFunds: (balance: number, required: number) =>
    cause({
      name: 'InsufficientFunds',
      message: `Insufficient funds. Balance: $${balance.toFixed(2)}, Required: $${required.toFixed(2)}`,
      currentBalance: balance,
      requiredAmount: required,
      shortAmount: required - balance,
    }),

  paymentMethodExpired: (methodId: string, expiryDate: Date) =>
    cause({
      name: 'PaymentMethodExpired',
      message: 'Payment method has expired',
      paymentMethodId: courseId,
      expiryDate: expiryDate.toISOString(),
      updateUrl: '/payment-methods/update',
    }),

  paymentDeclined: (reason: string, declineCode: string) =>
    cause({
      name: 'PaymentDeclined',
      message: `Payment declined: ${reason}`,
      reason,
      declineCode,
      tryDifferentMethod: true,
    }),

  processingError: (temporaryId: string) =>
    cause({
      name: 'ProcessingError',
      message: 'Payment processing error',
      temporaryId,
      retryAfter: 60, // seconds
      supportContact: 'support@payment.com',
    }),
};

const processPayment = t.mutation({
  args: z.object({
    amount: z.number().positive(),
    paymentMethodId: z.string(),
    orderId: z.string(),
  }),
  handler: async (ctx, args) => {
    // 1. Validate payment method
    const method = await ctx.database.paymentMethods.findById(args.paymentMethodId);
    if (!method) {
      return failureOutcome(
        Errors.notFound(args.paymentMethodId, 'Payment method')
      );
    }

    if (new Date(method.expiryDate) < new Date()) {
      return failureOutcome(
        PaymentErrors.paymentMethodExpired(args.paymentMethodId, method.expiryDate)
      );
    }

    // 2. Check user balance (for wallet payments)
    if (method.type === 'wallet') {
      const wallet = await ctx.database.wallets.findByUser(ctx.userId);
      if (wallet.balance < args.amount) {
        return failureOutcome(
          PaymentErrors.insufficientFunds(wallet.balance, args.amount)
        );
      }
    }

    // 3. Process payment
    try {
      const result = await ctx.paymentGateway.charge({
        amount: args.amount,
        method: args.paymentMethodId,
        orderId: args.orderId,
      });

      return success({
        transactionId: result.id,
        status: 'succeeded',
        amount: result.amount,
      });
    } catch (error) {
      if (error.declineCode) {
        return failureOutcome(
          PaymentErrors.paymentDeclined(
            error.message,
            error.declineCode
          )
        );
      }

      if (error.temporary) {
        return failureOutcome(
          PaymentErrors.processingError(result.temporaryId)
        );
      }

      return failure(error);
    }
  },
})
  .onError(async (ctx, args, error) => {
    // Log to error tracking
    await ctx.errorTracking.capture({
      operation: 'process_payment',
      userId: ctx.userId,
      amount: args.amount,
      paymentMethodId: args.paymentMethodId,
      error: error.message,
      timestamp: new Date(),
    });
  });
```

**Error Response Examples:**

```typescript
// Insufficient funds
{
  ok: false,
  error: {
    name: 'InsufficientFunds',
    message: 'Insufficient funds. Balance: $50.00, Required: $75.00',
    cause: {
      currentBalance: 50,
      requiredAmount: 75,
      shortAmount: 25
    }
  }
}

// Expired card
{
  ok: false,
  error: {
    name: 'PaymentMethodExpired',
    message: 'Payment method has expired',
    cause: {
      paymentMethodId: 'pm_123',
      expiryDate: '2023-01-01T00:00:00.000Z',
      updateUrl: '/payment-methods/update'
    }
  }
}
```

---

## What's Next?

Congratulations! You've completed Part 3: Advanced Patterns.

In **Part 4: Production Ready**, you'll learn:
- **Chapter 10:** Caching strategies for performance
- **Chapter 11:** Retry patterns for resilience
- **Chapter 12:** Testing your API end-to-end

Ready to make your API production-ready? Let's continue! ðŸš€

---

## Chapter Recap

You learned:
- âœ… Outcome types vs exceptions
- âœ… Creating custom error types with Causes
- âœ… Structured error responses
- âœ… Real-world payment error handling
- âœ… Error handling best practices

**Next up:** [Part 4: Production Ready](/learn/part-4-production/chapter-10-caching) â†’
